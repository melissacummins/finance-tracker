<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Management System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .nav-tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-tab.active {
            background: #667eea;
            color: white;
        }

        .nav-tab:hover:not(.active) {
            background: #f0f2f5;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.1);
        }

        .card h3 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.2em;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn-secondary {
            background: #718096;
        }

        .btn-secondary:hover {
            background: #4a5568;
        }

        .btn-danger {
            background: #e53e3e;
        }

        .btn-danger:hover {
            background: #c53030;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #4a5568;
        }

        .form-control {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
        }

        .grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .table th,
        .table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .table th {
            background: #f7fafc;
            font-weight: 600;
            color: #4a5568;
        }

        .table tr:hover {
            background: #f7fafc;
        }

        .upload-area {
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f7fafc;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            opacity: 0.9;
            font-size: 0.9em;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .nav-tabs {
                flex-direction: column;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .header > div {
                flex-direction: column !important;
                text-align: center !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h1>Financial Management System</h1>
                    <p>Import, categorize, and analyze your transactions with automated rules and projections</p>
                </div>
                <div id="authContainer">
                    <div id="signedOutContainer">
                        <button class="btn" onclick="signInWithGoogle()" style="background: #4285f4;">
                            üîê Sign in with Google
                        </button>
                    </div>
                    <div id="signedInContainer" style="display: none;">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="text-align: right;">
                                <div id="userDisplayName" style="font-weight: bold;"></div>
                                <div id="userEmail" style="font-size: 0.9em; opacity: 0.9;"></div>
                            </div>
                            <img id="userPhoto" style="width: 40px; height: 40px; border-radius: 50%; border: 2px solid white;">
                            <button class="btn btn-secondary" onclick="signOutUser()">Sign Out</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="syncStatus" style="margin-top: 10px; text-align: center; font-size: 0.9em; opacity: 0.9;">
                Sign in to sync data to the cloud
            </div>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('dashboard')">Dashboard</button>
            <button class="nav-tab" onclick="showTab('import')">Import Data</button>
            <button class="nav-tab" onclick="showTab('transactions')">Transactions</button>
            <button class="nav-tab" onclick="showTab('categories')">Categories</button>
            <button class="nav-tab" onclick="showTab('subscriptions')">Subscriptions</button>
            <button class="nav-tab" onclick="showTab('cashflow')">Cash Flow</button>
            <button class="nav-tab" onclick="showTab('rules')">Rules</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab-content active">
            <div class="dashboard-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalIncome">$0</div>
                    <div class="stat-label">Total Income</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalExpenses">$0</div>
                    <div class="stat-label">Total Expenses</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="netCashFlow">$0</div>
                    <div class="stat-label">Net Cash Flow</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="uncategorizedCount">0</div>
                    <div class="stat-label">Uncategorized Transactions</div>
                </div>
            </div>

            <div class="grid">
                <div class="card">
                    <h3>Recent Activity</h3>
                    <div id="recentTransactions">
                        <p>No transactions yet. Start by importing data or adding transactions manually.</p>
                    </div>
                </div>
                <div class="card">
                    <h3>Category Breakdown</h3>
                    <div id="categoryBreakdown">
                        <p>Categories will appear here once you add transactions.</p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Quick Actions</h3>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn" onclick="showTab('import')">Import Transactions</button>
                    <button class="btn btn-secondary" onclick="exportData()">Export Data</button>
                    <button class="btn btn-secondary" onclick="importData()">Import Data</button>
                </div>
            </div>
        </div>

        <!-- Import Data Tab -->
        <div id="import" class="tab-content">
            <div class="card">
                <h3>Import Transactions</h3>
                
                <div class="upload-area" id="uploadArea">
                    <p>Drag & drop your CSV/Excel file here or click to browse</p>
                    <input type="file" id="fileInput" accept=".csv,.xlsx,.xls" style="display: none;">
                </div>

                <div id="mappingSection" class="hidden">
                    <h4>Column Mapping</h4>
                    <p>Map your file columns to the appropriate fields:</p>
                    
                    <div id="columnMapping" style="margin: 20px 0;"></div>

                    <div class="form-group">
                        <label>Account Type</label>
                        <select id="accountType" class="form-control">
                            <option value="checking">Checking Account</option>
                            <option value="credit">Credit Card</option>
                            <option value="savings">Savings Account</option>
                        </select>
                    </div>

                    <button class="btn" onclick="processImport()">Import Transactions</button>
                </div>
            </div>
        </div>

        <!-- Transactions Tab -->
        <div id="transactions" class="tab-content">
            <div class="card">
                <h3>All Transactions</h3>
                
                <div class="form-group">
                    <input type="text" id="transactionSearch" class="form-control" placeholder="Search transactions...">
                </div>

                <div class="form-group">
                    <select id="categoryFilter" class="form-control">
                        <option value="">All Categories</option>
                        <option value="uncategorized">Uncategorized Only</option>
                    </select>
                </div>

                <!-- Bulk Actions -->
                <div id="bulkActions" class="hidden" style="background: #f7fafc; padding: 15px; border-radius: 6px; margin-bottom: 15px; border: 2px solid #e2e8f0;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span id="selectedCount">0 transactions selected</span>
                        <div style="display: flex; gap: 10px;">
                            <select id="bulkCategorySelect" class="form-control" style="width: 200px;">
                                <option value="">Choose category...</option>
                            </select>
                            <button class="btn" onclick="bulkSetCategory()">Set Category</button>
                            <button class="btn btn-danger" onclick="bulkDeleteTransactions()">Delete Selected</button>
                            <button class="btn btn-secondary" onclick="clearSelection()">Clear Selection</button>
                        </div>
                    </div>
                </div>

                <!-- Edit Transaction Form -->
                <div id="editTransactionForm" class="card hidden" style="background: #fff8e1; border: 2px solid #ffc107; margin-bottom: 15px;">
                    <h4>Edit Transaction</h4>
                    <div class="grid">
                        <div class="form-group">
                            <label>Date</label>
                            <input type="date" id="editTransactionDate" class="form-control">
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="number" step="0.01" id="editTransactionAmount" class="form-control">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <input type="text" id="editTransactionDescription" class="form-control">
                    </div>
                    <div class="form-group">
                        <label>Category</label>
                        <select id="editTransactionCategory" class="form-control">
                            <optgroup label="Income Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                            <optgroup label="Expense Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn" onclick="saveTransactionEdit()">Save Changes</button>
                        <button class="btn btn-secondary" onclick="cancelTransactionEdit()">Cancel</button>
                    </div>
                </div>

                <table class="table" id="transactionsTable">
                    <thead>
                        <tr>
                            <th><input type="checkbox" id="selectAllTransactions" onchange="toggleSelectAll()"></th>
                            <th>Date</th>
                            <th>Description</th>
                            <th>Amount</th>
                            <th>Category</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- Categories Tab -->
        <div id="categories" class="tab-content">
            <div class="grid">
                <div class="card">
                    <h3>Income Categories</h3>
                    
                    <!-- Add Income Category Form -->
                    <div id="addIncomeCategoryForm" class="hidden" style="background: #f0fff4; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <div class="form-group">
                            <input type="text" id="newIncomeCategory" class="form-control" placeholder="Enter income category name">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="saveNewCategory('income')">Add Category</button>
                            <button class="btn btn-secondary" onclick="cancelAddCategory('income')">Cancel</button>
                        </div>
                    </div>
                    
                    <div id="incomeCategories"></div>
                    <button class="btn" onclick="toggleAddCategoryForm('income')">Add Income Category</button>
                </div>
                <div class="card">
                    <h3>Expense Categories</h3>
                    
                    <!-- Add Expense Category Form -->
                    <div id="addExpenseCategoryForm" class="hidden" style="background: #fff5f5; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <div class="form-group">
                            <input type="text" id="newExpenseCategory" class="form-control" placeholder="Enter expense category name">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="saveNewCategory('expense')">Add Category</button>
                            <button class="btn btn-secondary" onclick="cancelAddCategory('expense')">Cancel</button>
                        </div>
                    </div>
                    
                    <div id="expenseCategories"></div>
                    <button class="btn" onclick="toggleAddCategoryForm('expense')">Add Expense Category</button>
                </div>
            </div>
        </div>

        <!-- Subscriptions Tab -->
        <div id="subscriptions" class="tab-content">
            <div class="card">
                <h3>Subscription Management</h3>
                <button class="btn" onclick="addSubscription()">Add Subscription</button>
                
                <div id="subscriptionsList"></div>
            </div>
        </div>

        <!-- Cash Flow Tab -->
        <div id="cashflow" class="tab-content">
            <div class="card">
                <h3>Cash Flow Analysis</h3>
                <p>Cash flow projections and analysis will be available here.</p>
            </div>
        </div>

        <!-- Rules Tab -->
        <div id="rules" class="tab-content">
            <div class="card">
                <h3>Categorization Rules</h3>
                <p>Create rules to automatically categorize transactions based on description patterns. Rules are applied in order when importing new transactions.</p>
                
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn" onclick="toggleAddRuleForm()">Add New Rule</button>
                    <button class="btn btn-secondary" onclick="applyRulesToExistingTransactions()">Apply Rules to Existing Transactions</button>
                </div>
                
                <!-- Add Rule Form -->
                <div id="addRuleForm" class="card hidden" style="background: #f7fafc; border: 2px solid #e2e8f0;">
                    <h4>Create New Rule</h4>
                    <div class="grid">
                        <div class="form-group">
                            <label>Rule Name</label>
                            <input type="text" id="newRuleName" class="form-control" placeholder="e.g., Netflix Subscription">
                        </div>
                        <div class="form-group">
                            <label>If Description</label>
                            <select id="newRuleConditionType" class="form-control">
                                <option value="contains">Contains</option>
                                <option value="starts_with">Starts With</option>
                                <option value="ends_with">Ends With</option>
                                <option value="equals">Equals Exactly</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Text to Match</label>
                        <input type="text" id="newRuleConditionValue" class="form-control" placeholder="e.g., NETFLIX">
                    </div>
                    <div class="form-group">
                        <label>Then Set Category To</label>
                        <select id="newRuleCategory" class="form-control">
                            <optgroup label="Income Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                            <optgroup label="Expense Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn" onclick="saveNewRule()">Save Rule</button>
                        <button class="btn btn-secondary" onclick="cancelAddRule()">Cancel</button>
                    </div>
                </div>
                
                <div id="rulesList"></div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK v9 -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc, updateDoc, deleteDoc, query, where, getDocs, orderBy } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCfcKmWAg7rnxVao5hNfgexb8FfPkwu2ww",
            authDomain: "income-expenses-cash-flow.firebaseapp.com",
            projectId: "income-expenses-cash-flow",
            storageBucket: "income-expenses-cash-flow.firebasestorage.app",
            messagingSenderId: "489754288851",
            appId: "1:489754288851:web:a8151822e2066535746a26",
            measurementId: "G-72Q1KQ4TFR"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();
        provider.addScope('email');
        provider.addScope('profile');
        
        window.firebaseServices = {
            auth, db, provider, signInWithPopup, signOut, onAuthStateChanged,
            doc, setDoc, getDoc, collection, addDoc, updateDoc, deleteDoc, 
            query, where, getDocs, orderBy
        };
        
        window.dispatchEvent(new Event('firebaseReady'));
    </script>

    <script>
        // Global data storage
        let transactions = [];
        let categories = {
            income: ['Direct Sales', 'Amazon', 'Kobo', 'Draft2Digital', 'Google Play', 'Patreon', 'Findaway', 'Kickstarter'],
            expense: ['Services', 'Shipping', 'Production', 'Marketing', 'Education', 'Business']
        };
        let rules = [];
        let subscriptions = [];
        let currentUser = null;
        let firebaseReady = false;

        // Wait for Firebase to be ready
        window.addEventListener('firebaseReady', function() {
            firebaseReady = true;
            initializeAuth();
        });

        // Authentication Functions
        function initializeAuth() {
            window.firebaseServices.onAuthStateChanged(window.firebaseServices.auth, (user) => {
                if (user) {
                    currentUser = user;
                    showSignedInState(user);
                    loadUserData();
                } else {
                    currentUser = null;
                    showSignedOutState();
                }
            });
        }

        function showSignedInState(user) {
            document.getElementById('signedOutContainer').style.display = 'none';
            document.getElementById('signedInContainer').style.display = 'block';
            document.getElementById('userDisplayName').textContent = user.displayName || 'User';
            document.getElementById('userEmail').textContent = user.email;
            document.getElementById('userPhoto').src = user.photoURL || '';
            document.getElementById('syncStatus').textContent = 'Connected - Data syncing to cloud';
        }

        function showSignedOutState() {
            document.getElementById('signedOutContainer').style.display = 'block';
            document.getElementById('signedInContainer').style.display = 'none';
            document.getElementById('syncStatus').textContent = 'Sign in to sync data to the cloud';
        }

        async function signInWithGoogle() {
            if (!firebaseReady) {
                alert('Firebase is not ready yet. Please wait a moment and try again.');
                return;
            }

            try {
                const result = await window.firebaseServices.signInWithPopup(window.firebaseServices.auth, window.firebaseServices.provider);
                console.log('Sign in successful:', result.user.email);
            } catch (error) {
                console.error('Sign in error:', error);
                if (error.code === 'auth/popup-blocked') {
                    alert('Popup was blocked. Please allow popups for this site and try again.');
                } else if (error.code === 'auth/popup-closed-by-user') {
                    alert('Sign in was cancelled.');
                } else {
                    alert('Failed to sign in: ' + error.message);
                }
            }
        }

        async function signOutUser() {
            try {
                await window.firebaseServices.signOut(window.firebaseServices.auth);
                console.log('User signed out');
            } catch (error) {
                console.error('Error signing out:', error);
            }
        }

        // Data Management
        async function loadUserData() {
            if (!currentUser || !firebaseReady) return;
            
            try {
                const userDocRef = window.firebaseServices.doc(window.firebaseServices.db, 'users', currentUser.uid);
                const userDoc = await window.firebaseServices.getDoc(userDocRef);
                
                if (userDoc.exists()) {
                    const data = userDoc.data();
                    transactions = data.transactions || [];
                    categories = data.categories || categories;
                    rules = data.rules || [];
                    subscriptions = data.subscriptions || [];
                } else {
                    await saveUserData();
                }
                
                updateDashboard();
                updateTransactionsTable();
                updateCategoriesView();
                
            } catch (error) {
                console.error('Error loading user data:', error);
            }
        }

        async function saveUserData() {
            if (!currentUser || !firebaseReady) return;
            
            try {
                const data = {
                    transactions,
                    categories,
                    rules,
                    subscriptions,
                    lastSaved: new Date().toISOString(),
                    userId: currentUser.uid
                };
                
                const userDocRef = window.firebaseServices.doc(window.firebaseServices.db, 'users', currentUser.uid);
                await window.firebaseServices.setDoc(userDocRef, data);
                
            } catch (error) {
                console.error('Error saving user data:', error);
            }
        }

        // UI Functions
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        function updateDashboard() {
            // Use ALL transactions, not just current month
            const activeTransactions = transactions.filter(t => !t.excludeFromTotals);

            const totalIncome = activeTransactions
                .filter(t => t.amount > 0)
                .reduce((sum, t) => sum + t.amount, 0);

            const totalExpenses = activeTransactions
                .filter(t => t.amount < 0)
                .reduce((sum, t) => sum + Math.abs(t.amount), 0);

            const uncategorizedCount = transactions.filter(t => 
                (t.category === 'Uncategorized' || !t.category) && !t.excludeFromTotals
            ).length;

            const duplicateCount = transactions.filter(t => t.isDuplicateFlag).length;

            document.getElementById('totalIncome').textContent = formatCurrency(totalIncome);
            document.getElementById('totalExpenses').textContent = formatCurrency(totalExpenses);
            document.getElementById('netCashFlow').textContent = formatCurrency(totalIncome - totalExpenses);
            document.getElementById('uncategorizedCount').textContent = uncategorizedCount;

            // Add duplicate alert if there are flagged duplicates
            updateDuplicateAlert(duplicateCount);
            updateRecentTransactions();
            updateCategoryBreakdown();
        }

        function updateCategoryBreakdown() {
            const container = document.getElementById('categoryBreakdown');
            const activeTransactions = transactions.filter(t => !t.excludeFromTotals);
            
            if (activeTransactions.length === 0) {
                container.innerHTML = '<p>Categories will appear here once you add transactions.</p>';
                return;
            }

            // Group transactions by category and calculate totals
            const categoryTotals = {};
            activeTransactions.forEach(t => {
                const category = t.category || 'Uncategorized';
                if (!categoryTotals[category]) {
                    categoryTotals[category] = 0;
                }
                categoryTotals[category] += Math.abs(t.amount);
            });

            // Sort categories by total amount (descending)
            const sortedCategories = Object.entries(categoryTotals)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 10); // Show top 10 categories

            const totalAmount = Object.values(categoryTotals).reduce((sum, amount) => sum + amount, 0);

            container.innerHTML = `
                <div style="max-height: 300px; overflow-y: auto;">
                    ${sortedCategories.map(([category, amount]) => {
                        const percentage = totalAmount > 0 ? (amount / totalAmount * 100).toFixed(1) : 0;
                        return `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
                                <div>
                                    <strong>${category}</strong>
                                    <div style="width: 100px; height: 6px; background: #e2e8f0; border-radius: 3px; margin-top: 3px;">
                                        <div style="width: ${percentage}%; height: 100%; background: #667eea; border-radius: 3px;"></div>
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-weight: bold;">${formatCurrency(amount)}</div>
                                    <div style="font-size: 0.8em; color: #718096;">${percentage}%</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #e2e8f0; font-weight: bold;">
                    Total: ${formatCurrency(totalAmount)}
                </div>
            `;
        }

        function updateDuplicateAlert(duplicateCount) {
            // Remove existing alert
            const existingAlert = document.getElementById('duplicateAlert');
            if (existingAlert) {
                existingAlert.remove();
            }

            if (duplicateCount > 0) {
                const dashboardGrid = document.querySelector('.dashboard-grid');
                const alertHtml = `
                    <div id="duplicateAlert" class="stat-card" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">
                        <div class="stat-value">${duplicateCount}</div>
                        <div class="stat-label">Flagged Duplicates</div>
                        <button class="btn btn-secondary" onclick="showDuplicateManager()" style="margin-top: 10px; padding: 5px 10px; font-size: 0.8em;">
                            Review Duplicates
                        </button>
                    </div>
                `;
                dashboardGrid.insertAdjacentHTML('beforeend', alertHtml);
            }
        }

        function resolveDuplicate(transactionId) {
            const transaction = transactions.find(t => t.id === transactionId);
            if (!transaction) return;

            const options = [
                "Keep this transaction (mark as legitimate)",
                "Delete this transaction (it's a duplicate)",
                "Keep all in this group (legitimate multiple charges)",
                "Review all duplicates in group"
            ];

            const choice = prompt(`Resolve duplicate for: ${transaction.description}\n\n` +
                `1. ${options[0]}\n2. ${options[1]}\n3. ${options[2]}\n4. ${options[3]}\n\n` +
                "Enter number (1-4):", "1");

            const choiceNum = parseInt(choice);
            
            switch (choiceNum) {
                case 1:
                    // Keep this one, mark as legitimate
                    transaction.isDuplicateFlag = false;
                    transaction.excludeFromTotals = false;
                    delete transaction.duplicateGroup;
                    break;
                    
                case 2:
                    // Delete this transaction
                    transactions = transactions.filter(t => t.id !== transactionId);
                    break;
                    
                case 3:
                    // Keep all in group
                    const groupId = transaction.duplicateGroup;
                    transactions.forEach(t => {
                        if (t.duplicateGroup === groupId) {
                            t.isDuplicateFlag = false;
                            t.excludeFromTotals = false;
                            delete t.duplicateGroup;
                        }
                    });
                    break;
                    
                case 4:
                    // Show duplicate manager
                    showDuplicateManager();
                    return;
                    
                default:
                    return;
            }

            updateDashboard();
            updateTransactionsTable();
            saveUserData();
            
            if (choiceNum !== 4) {
                alert('Duplicate resolved!');
            }
        }

        function showDuplicateManager() {
            const duplicateGroups = {};
            
            // Group duplicates
            transactions.forEach(t => {
                if (t.isDuplicateFlag && t.duplicateGroup) {
                    if (!duplicateGroups[t.duplicateGroup]) {
                        duplicateGroups[t.duplicateGroup] = [];
                    }
                    duplicateGroups[t.duplicateGroup].push(t);
                }
            });

            let message = "DUPLICATE MANAGER\n\n";
            message += "Flagged transactions excluded from totals:\n\n";

            Object.keys(duplicateGroups).forEach((groupId, index) => {
                const group = duplicateGroups[groupId];
                message += `GROUP ${index + 1}:\n`;
                group.forEach((t, i) => {
                    message += `  ${i + 1}. ${formatDate(t.date)} - ${t.description} - ${formatCurrency(t.amount)}\n`;
                });
                message += "\n";
            });

            message += "Go to Transactions tab to resolve individual duplicates,\n";
            message += "or use bulk operations to manage multiple transactions.";

            alert(message);
        }

        function updateRecentTransactions() {
            const recent = transactions
                .filter(t => !t.excludeFromTotals) // Exclude flagged duplicates
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 5);

            const container = document.getElementById('recentTransactions');
            container.innerHTML = recent.length ? recent.map(t => `
                <div style="padding: 10px; border-bottom: 1px solid #e2e8f0;">
                    <strong>${t.description}</strong><br>
                    <small>${formatDate(t.date)} - ${t.category || 'Uncategorized'}</small>
                    <span style="float: right; color: ${t.amount > 0 ? 'green' : 'red'};">
                        ${formatCurrency(t.amount)}
                    </span>
                </div>
            `).join('') : '<p>No transactions yet. Start by importing data or adding transactions manually.</p>';
        }

        function updateTransactionsTable() {
            const tbody = document.querySelector('#transactionsTable tbody');
            const searchTerm = document.getElementById('transactionSearch')?.value.toLowerCase() || '';
            const categoryFilter = document.getElementById('categoryFilter')?.value || '';
            
            let filteredTransactions = transactions;
            
            // Apply search filter
            if (searchTerm) {
                filteredTransactions = filteredTransactions.filter(t => 
                    t.description.toLowerCase().includes(searchTerm) ||
                    (t.category && t.category.toLowerCase().includes(searchTerm))
                );
            }
            
            // Apply category filter
            if (categoryFilter) {
                if (categoryFilter === 'uncategorized') {
                    filteredTransactions = filteredTransactions.filter(t => 
                        !t.category || t.category === 'Uncategorized'
                    );
                } else {
                    filteredTransactions = filteredTransactions.filter(t => 
                        t.category === categoryFilter
                    );
                }
            }
            
            // Sort by date (newest first)
            filteredTransactions.sort((a, b) => new Date(b.date) - new Date(a.date));
            
            tbody.innerHTML = filteredTransactions.map(t => `
                <tr style="${t.isDuplicateFlag ? 'background-color: #fef3cd; border-left: 4px solid #f59e0b;' : ''}">
                    <td><input type="checkbox" class="transaction-checkbox" value="${t.id}" onchange="updateBulkActions()"></td>
                    <td>${formatDate(t.date)}</td>
                    <td>
                        ${t.description}
                        ${t.isDuplicateFlag ? '<span style="background: #f59e0b; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7em; margin-left: 5px;">DUPLICATE?</span>' : ''}
                    </td>
                    <td style="color: ${t.amount > 0 ? 'green' : 'red'};">
                        ${formatCurrency(t.amount)}
                        ${t.excludeFromTotals ? '<br><small style="color: #f59e0b;">Excluded from totals</small>' : ''}
                    </td>
                    <td>${t.category || 'Uncategorized'}</td>
                    <td>
                        <button class="btn btn-secondary" onclick="editTransaction('${t.id}')" style="padding: 5px 10px; margin: 2px;">Edit</button>
                        ${t.isDuplicateFlag ? 
                            `<button class="btn" onclick="resolveDuplicate('${t.id}')" style="padding: 5px 10px; margin: 2px; background: #059669;">Resolve</button>` :
                            ''
                        }
                        <button class="btn btn-danger" onclick="deleteTransaction('${t.id}')" style="padding: 5px 10px; margin: 2px;">Delete</button>
                    </td>
                </tr>
            `).join('');
            
            // Update category filter options
            updateCategoryFilterOptions();
            updateBulkCategoryOptions();
            
            // Reset bulk selection
            clearSelection();
        }

        function updateBulkCategoryOptions() {
            const bulkCategorySelect = document.getElementById('bulkCategorySelect');
            if (!bulkCategorySelect) return;
            
            const allCategories = [...categories.income, ...categories.expense];
            
            bulkCategorySelect.innerHTML = `
                <option value="">Choose category...</option>
                <optgroup label="Income Categories">
                    ${categories.income.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </optgroup>
                <optgroup label="Expense Categories">
                    ${categories.expense.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </optgroup>
            `;
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAllTransactions');
            const checkboxes = document.querySelectorAll('.transaction-checkbox');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAll.checked;
            });
            
            updateBulkActions();
        }

        function updateBulkActions() {
            const checkboxes = document.querySelectorAll('.transaction-checkbox:checked');
            const bulkActions = document.getElementById('bulkActions');
            const selectedCount = document.getElementById('selectedCount');
            const selectAll = document.getElementById('selectAllTransactions');
            
            const count = checkboxes.length;
            selectedCount.textContent = `${count} transaction${count !== 1 ? 's' : ''} selected`;
            
            if (count > 0) {
                bulkActions.classList.remove('hidden');
            } else {
                bulkActions.classList.add('hidden');
            }
            
            // Update select all checkbox state
            const allCheckboxes = document.querySelectorAll('.transaction-checkbox');
            if (count === 0) {
                selectAll.indeterminate = false;
                selectAll.checked = false;
            } else if (count === allCheckboxes.length) {
                selectAll.indeterminate = false;
                selectAll.checked = true;
            } else {
                selectAll.indeterminate = true;
            }
        }

        function clearSelection() {
            document.querySelectorAll('.transaction-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            document.getElementById('selectAllTransactions').checked = false;
            document.getElementById('selectAllTransactions').indeterminate = false;
            updateBulkActions();
        }

        function bulkSetCategory() {
            const selectedCategory = document.getElementById('bulkCategorySelect').value;
            if (!selectedCategory) {
                alert('Please select a category');
                return;
            }
            
            const checkboxes = document.querySelectorAll('.transaction-checkbox:checked');
            const selectedIds = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                alert('No transactions selected');
                return;
            }
            
            if (confirm(`Set category to "${selectedCategory}" for ${selectedIds.length} transaction${selectedIds.length !== 1 ? 's' : ''}?`)) {
                selectedIds.forEach(id => {
                    const transaction = transactions.find(t => t.id === id);
                    if (transaction) {
                        transaction.category = selectedCategory;
                    }
                });
                
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
                
                alert(`Updated ${selectedIds.length} transactions`);
            }
        }

        function bulkDeleteTransactions() {
            const checkboxes = document.querySelectorAll('.transaction-checkbox:checked');
            const selectedIds = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                alert('No transactions selected');
                return;
            }
            
            if (confirm(`Delete ${selectedIds.length} transaction${selectedIds.length !== 1 ? 's' : ''}? This cannot be undone.`)) {
                transactions = transactions.filter(t => !selectedIds.includes(t.id));
                
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
                
                alert(`Deleted ${selectedIds.length} transactions`);
            }
        }

        function updateCategoryFilterOptions() {
            const categoryFilter = document.getElementById('categoryFilter');
            if (!categoryFilter) return;
            
            const allCategories = [...new Set(transactions.map(t => t.category).filter(c => c))];
            const currentValue = categoryFilter.value;
            
            categoryFilter.innerHTML = `
                <option value="">All Categories</option>
                <option value="uncategorized">Uncategorized Only</option>
                ${allCategories.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
            `;
            
            categoryFilter.value = currentValue;
        }

        // Add event listeners for search and filter
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('transactionSearch');
            const categoryFilter = document.getElementById('categoryFilter');
            
            if (searchInput) {
                searchInput.addEventListener('input', updateTransactionsTable);
            }
            
            if (categoryFilter) {
                categoryFilter.addEventListener('change', updateTransactionsTable);
            }

            // Add Enter key support for forms
            document.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    // Check if we're in a category form
                    if (e.target.id === 'newIncomeCategory') {
                        saveNewCategory('income');
                    } else if (e.target.id === 'newExpenseCategory') {
                        saveNewCategory('expense');
                    } else if (e.target.closest('#addRuleForm')) {
                        // If in rule form, save the rule
                        const saveButton = document.querySelector('#addRuleForm .btn[onclick*="Rule"]');
                        if (saveButton) {
                            saveButton.click();
                        }
                    }
                }
            });
        });

        function updateCategoriesView() {
            const incomeContainer = document.getElementById('incomeCategories');
            const expenseContainer = document.getElementById('expenseCategories');
            
            incomeContainer.innerHTML = categories.income.map(cat => `
                <div style="padding: 10px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
                    <span>${cat}</span>
                    <button class="btn btn-danger" onclick="deleteCategory('income', '${cat}')">Delete</button>
                </div>
            `).join('');
            
            expenseContainer.innerHTML = categories.expense.map(cat => `
                <div style="padding: 10px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
                    <span>${cat}</span>
                    <button class="btn btn-danger" onclick="deleteCategory('expense', '${cat}')">Delete</button>
                </div>
            `).join('');
        }

        // Utility Functions
        function formatCurrency(amount) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD'
            }).format(amount);
        }

        function formatDate(date) {
            return new Date(date).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }

        // CSV Import functionality
        let csvData = [];
        let csvHeaders = [];

        // Set up file input and upload area
        document.addEventListener('DOMContentLoaded', function() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#667eea';
                uploadArea.style.background = '#f7fafc';
            });
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#cbd5e0';
                uploadArea.style.background = 'transparent';
            });
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#cbd5e0';
                uploadArea.style.background = 'transparent';
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });
        });

        function handleFileUpload(file) {
            if (!file.name.toLowerCase().match(/\.(csv|xlsx|xls)$/)) {
                alert('Please upload a CSV or Excel file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            // Improved CSV parsing to handle quoted fields, commas in quotes, etc.
            const lines = text.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                alert('CSV file must have at least a header and one data row.');
                return;
            }

            // Parse CSV with proper quote handling
            function parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const nextChar = line[i + 1];
                    
                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            // Escaped quote
                            current += '"';
                            i++; // Skip next quote
                        } else {
                            // Toggle quote state
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        // End of field
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                // Add the last field
                result.push(current.trim());
                return result;
            }

            csvHeaders = parseCSVLine(lines[0]);
            csvData = [];

            // Parse each data line
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines
                
                const values = parseCSVLine(line);
                
                // Create object from headers and values
                const row = {};
                csvHeaders.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                
                csvData.push(row);
            }

            console.log(`Parsed ${csvData.length} rows from CSV`);
            console.log('Sample row:', csvData[0]);
            
            showColumnMapping();
        }

        function showColumnMapping() {
            const mappingSection = document.getElementById('mappingSection');
            const columnMapping = document.getElementById('columnMapping');
            
            mappingSection.classList.remove('hidden');

            const fieldMappings = [
                { field: 'date', label: 'Date', required: true },
                { field: 'description', label: 'Description', required: true },
                { field: 'amount', label: 'Amount', required: true },
                { field: 'transactionType', label: 'Transaction Type (Debit/Credit)', required: false },
                { field: 'category', label: 'Category', required: false }
            ];

            columnMapping.innerHTML = fieldMappings.map(mapping => `
                <div class="form-group">
                    <label>${mapping.label} ${mapping.required ? '*' : ''}</label>
                    <select id="mapping_${mapping.field}" class="form-control">
                        <option value="">-- Select Column --</option>
                        ${csvHeaders.map(header => `<option value="${header}">${header}</option>`).join('')}
                    </select>
                </div>
            `).join('');

            // Auto-detect common column names
            autoMapColumns();
        }

        function autoMapColumns() {
            const commonMappings = {
                date: ['date', 'transaction date', 'posted date', 'trans date', 'posting date'],
                description: ['description', 'memo', 'payee', 'merchant', 'details', 'transaction description'],
                amount: ['amount', 'transaction amount', 'debit', 'credit', 'transaction amt'],
                transactionType: ['transaction type', 'type', 'debit/credit', 'dr/cr', 'transaction kind'],
                category: ['category', 'transaction category', 'classification']
            };

            Object.keys(commonMappings).forEach(field => {
                const select = document.getElementById(`mapping_${field}`);
                if (select) {
                    const matchingHeader = csvHeaders.find(header => 
                        commonMappings[field].some(pattern => 
                            header.toLowerCase().includes(pattern.toLowerCase())
                        )
                    );
                    if (matchingHeader) {
                        select.value = matchingHeader;
                    }
                }
            });
        }

        function processImport() {
            const mappings = {
                date: document.getElementById('mapping_date').value,
                description: document.getElementById('mapping_description').value,
                amount: document.getElementById('mapping_amount').value,
                transactionType: document.getElementById('mapping_transactionType').value,
                category: document.getElementById('mapping_category').value
            };

            if (!mappings.date || !mappings.description || !mappings.amount) {
                alert('Please map the required fields: Date, Description, and Amount');
                return;
            }

            const accountType = document.getElementById('accountType').value;
            let importedCount = 0;
            let skippedCount = 0;
            let detectedSubscriptions = [];
            const importErrors = [];

            console.log(`Processing ${csvData.length} rows...`);

            csvData.forEach((row, index) => {
                const dateStr = row[mappings.date];
                const description = row[mappings.description];
                const amountStr = row[mappings.amount];
                const transactionType = row[mappings.transactionType] || '';
                const category = row[mappings.category] || 'Uncategorized';

                if (!dateStr || !description || !amountStr) {
                    skippedCount++;
                    importErrors.push(`Row ${index + 2}: Missing required fields`);
                    return;
                }

                // Parse date with multiple format support
                let date;
                try {
                    // Try different date formats
                    let parsedDate;
                    
                    // Check for MM/DD/YYYY, MM-DD-YYYY, etc.
                    if (dateStr.match(/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$/)) {
                        parsedDate = new Date(dateStr);
                    }
                    // Check for YYYY-MM-DD
                    else if (dateStr.match(/^\d{4}-\d{1,2}-\d{1,2}$/)) {
                        parsedDate = new Date(dateStr);
                    }
                    // Check for DD/MM/YYYY (European format)
                    else if (dateStr.match(/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4}$/) && dateStr.split(/[\/\-]/)[0] > 12) {
                        const parts = dateStr.split(/[\/\-]/);
                        parsedDate = new Date(`${parts[1]}/${parts[0]}/${parts[2]}`);
                    }
                    else {
                        parsedDate = new Date(dateStr);
                    }
                    
                    if (isNaN(parsedDate.getTime())) {
                        throw new Error('Invalid date');
                    }
                    
                    date = parsedDate.toISOString().split('T')[0];
                } catch (e) {
                    skippedCount++;
                    importErrors.push(`Row ${index + 2}: Invalid date "${dateStr}"`);
                    return;
                }

                // Parse amount with better handling
                let amount = parseFloat(amountStr.replace(/[$,\s()]/g, '').replace(/[^\d.-]/g, ''));
                if (isNaN(amount)) {
                    skippedCount++;
                    importErrors.push(`Row ${index + 2}: Invalid amount "${amountStr}"`);
                    return;
                }

                // Handle transaction type (debit/credit)
                if (mappings.transactionType && transactionType) {
                    const type = transactionType.toLowerCase();
                    if (type.includes('debit') || type.includes('withdrawal') || type.includes('payment') || type.includes('purchase')) {
                        amount = -Math.abs(amount); // Make negative for debits
                    } else if (type.includes('credit') || type.includes('deposit') || type.includes('income') || type.includes('refund')) {
                        amount = Math.abs(amount); // Make positive for credits
                    }
                } else {
                    // For credit cards, flip the sign if needed (fallback)
                    if (accountType === 'credit' && amount > 0) {
                        amount = -amount;
                    }
                }

                // Apply categorization rules
                const appliedCategory = applyCategorationRules(description, category);

                const transaction = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                    date: date,
                    description: description.trim(),
                    amount: amount,
                    category: appliedCategory,
                    transactionType: transactionType,
                    accountType: accountType,
                    imported: true,
                    importDate: new Date().toISOString()
                };

                // Check for duplicates with smart handling
                const potentialDuplicate = transactions.find(t => 
                    t.date === transaction.date && 
                    t.description.toLowerCase() === transaction.description.toLowerCase() && 
                    Math.abs(t.amount - transaction.amount) < 0.01
                );

                if (potentialDuplicate && !potentialDuplicate.isDuplicateFlag) {
                    // Mark both transactions as potential duplicates
                    transaction.isDuplicateFlag = true;
                    transaction.duplicateGroup = potentialDuplicate.id;
                    transaction.excludeFromTotals = true;
                    
                    potentialDuplicate.isDuplicateFlag = true;
                    potentialDuplicate.duplicateGroup = potentialDuplicate.id; // Group leader
                    potentialDuplicate.excludeFromTotals = true;
                    
                    transactions.push(transaction);
                    importedCount++;
                    skippedCount++; // Also count as flagged
                    importErrors.push(`Row ${index + 2}: Potential duplicate flagged for review`);

                    // Detect potential subscriptions (negative amounts, recurring patterns)
                    if (amount < 0) {
                        detectSubscription(transaction, detectedSubscriptions);
                    }
                } else if (potentialDuplicate && potentialDuplicate.isDuplicateFlag) {
                    // Add to existing duplicate group
                    transaction.isDuplicateFlag = true;
                    transaction.duplicateGroup = potentialDuplicate.duplicateGroup;
                    transaction.excludeFromTotals = true;
                    
                    transactions.push(transaction);
                    importedCount++;
                    importErrors.push(`Row ${index + 2}: Added to duplicate group for review`);
                } else {
                    // No duplicate, import normally
                    transactions.push(transaction);
                    importedCount++;

                    // Detect potential subscriptions (negative amounts, recurring patterns)
                    if (amount < 0) {
                        detectSubscription(transaction, detectedSubscriptions);
                    }
                }
            });

            // Process detected subscriptions
            if (detectedSubscriptions.length > 0) {
                processDetectedSubscriptions(detectedSubscriptions);
            }

            // Show detailed results
            let message = `Import completed!\n\n`;
            message += `‚úÖ Imported: ${importedCount} transactions\n`;
            if (skippedCount > 0) {
                message += `‚ö†Ô∏è Skipped: ${skippedCount} transactions (duplicates or errors)\n`;
            }
            if (detectedSubscriptions.length > 0) {
                message += `üîÑ Found: ${detectedSubscriptions.length} potential subscriptions\n`;
            }
            if (importErrors.length > 0 && importErrors.length <= 5) {
                message += `\nErrors:\n${importErrors.slice(0, 5).join('\n')}`;
            } else if (importErrors.length > 5) {
                message += `\nFirst 5 errors:\n${importErrors.slice(0, 5).join('\n')}\n... and ${importErrors.length - 5} more`;
            }

            alert(message);

            if (importedCount > 0) {
                updateDashboard();
                updateTransactionsTable();
                updateSubscriptionsView();
                saveUserData();
            }
            
            // Reset the import form
            document.getElementById('mappingSection').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            csvData = [];
            csvHeaders = [];
        }

        function applyCategorationRules(description, defaultCategory) {
            const desc = description.toLowerCase();
            
            // Apply rules in order of priority
            for (const rule of rules) {
                if (rule.conditions.some(condition => {
                    switch (condition.type) {
                        case 'contains':
                            return desc.includes(condition.value.toLowerCase());
                        case 'starts_with':
                            return desc.startsWith(condition.value.toLowerCase());
                        case 'ends_with':
                            return desc.endsWith(condition.value.toLowerCase());
                        case 'equals':
                            return desc === condition.value.toLowerCase();
                        default:
                            return false;
                    }
                })) {
                    return rule.category;
                }
            }
            
            return defaultCategory;
        }

        function detectSubscription(transaction, detectedSubscriptions) {
            const desc = transaction.description.toLowerCase();
            
            // Common subscription keywords
            const subscriptionKeywords = [
                'netflix', 'spotify', 'amazon prime', 'hulu', 'disney', 'apple music',
                'adobe', 'microsoft', 'google', 'dropbox', 'office 365',
                'gym', 'fitness', 'insurance', 'phone', 'internet', 'cable',
                'subscription', 'monthly', 'annual', 'recurring'
            ];

            const isLikelySubscription = subscriptionKeywords.some(keyword => desc.includes(keyword)) ||
                                      desc.includes('auto pay') || 
                                      desc.includes('recurring') ||
                                      desc.includes('monthly');

            if (isLikelySubscription) {
                // Check if we already detected this vendor
                const existingSubscription = detectedSubscriptions.find(sub => 
                    sub.vendor.toLowerCase() === transaction.description.toLowerCase()
                );

                if (existingSubscription) {
                    existingSubscription.transactions.push(transaction);
                    // Update amount if it's different (price change)
                    if (Math.abs(existingSubscription.amount - Math.abs(transaction.amount)) > 0.01) {
                        existingSubscription.priceChanged = true;
                        existingSubscription.newAmount = Math.abs(transaction.amount);
                    }
                } else {
                    detectedSubscriptions.push({
                        vendor: transaction.description,
                        amount: Math.abs(transaction.amount),
                        category: transaction.category,
                        lastDate: transaction.date,
                        transactions: [transaction],
                        priceChanged: false
                    });
                }
            }
        }

        function processDetectedSubscriptions(detectedSubscriptions) {
            detectedSubscriptions.forEach(detected => {
                // Check if subscription already exists
                const existingSubscription = subscriptions.find(sub => 
                    sub.vendor.toLowerCase() === detected.vendor.toLowerCase()
                );

                if (!existingSubscription) {
                    // Calculate frequency based on transaction dates
                    let frequency = 'monthly'; // default
                    if (detected.transactions.length > 1) {
                        const dates = detected.transactions.map(t => new Date(t.date)).sort();
                        const daysBetween = (dates[1] - dates[0]) / (1000 * 60 * 60 * 24);
                        if (daysBetween > 300) frequency = 'annual';
                        else if (daysBetween > 80) frequency = 'quarterly';
                        else frequency = 'monthly';
                    }

                    subscriptions.push({
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                        vendor: detected.vendor,
                        amount: detected.amount,
                        frequency: frequency,
                        category: detected.category,
                        lastCharge: detected.lastDate,
                        status: 'active',
                        autoDetected: true,
                        priceChanged: detected.priceChanged,
                        newAmount: detected.newAmount || detected.amount,
                        detectedDate: new Date().toISOString()
                    });
                } else if (detected.priceChanged) {
                    // Update existing subscription with new amount
                    existingSubscription.amount = detected.newAmount;
                    existingSubscription.priceChanged = true;
                    existingSubscription.lastCharge = detected.lastDate;
                }
            });
        }

        // Other functions
        function addCategory(type) { 
            toggleAddCategoryForm(type);
        }

        function toggleAddCategoryForm(type) {
            const form = document.getElementById(`add${type.charAt(0).toUpperCase() + type.slice(1)}CategoryForm`);
            const input = document.getElementById(`new${type.charAt(0).toUpperCase() + type.slice(1)}Category`);
            
            if (form.classList.contains('hidden')) {
                form.classList.remove('hidden');
                input.value = '';
                input.focus();
            } else {
                form.classList.add('hidden');
            }
        }

        function saveNewCategory(type) {
            const input = document.getElementById(`new${type.charAt(0).toUpperCase() + type.slice(1)}Category`);
            const name = input.value.trim();
            
            if (!name) {
                alert('Please enter a category name');
                return;
            }
            
            if (categories[type].includes(name)) {
                alert('Category already exists');
                return;
            }
            
            categories[type].push(name);
            updateCategoriesView();
            saveUserData();
            
            // Hide the form
            document.getElementById(`add${type.charAt(0).toUpperCase() + type.slice(1)}CategoryForm`).classList.add('hidden');
        }

        function cancelAddCategory(type) {
            document.getElementById(`add${type.charAt(0).toUpperCase() + type.slice(1)}CategoryForm`).classList.add('hidden');
        }

        function deleteCategory(type, name) {
            if (confirm(`Delete "${name}" category?`)) {
                categories[type] = categories[type].filter(cat => cat !== name);
                updateCategoriesView();
                saveUserData();
            }
        }

        function editTransaction(id) { 
            const transaction = transactions.find(t => t.id === id);
            if (!transaction) return;

            // Show the edit form
            const form = document.getElementById('editTransactionForm');
            form.classList.remove('hidden');
            
            // Populate the form
            document.getElementById('editTransactionDate').value = transaction.date;
            document.getElementById('editTransactionDescription').value = transaction.description;
            document.getElementById('editTransactionAmount').value = transaction.amount;
            
            // Populate categories dropdown
            const categorySelect = document.getElementById('editTransactionCategory');
            const incomeOptgroup = categorySelect.querySelector('optgroup[label="Income Categories"]');
            const expenseOptgroup = categorySelect.querySelector('optgroup[label="Expense Categories"]');
            
            incomeOptgroup.innerHTML = categories.income.map(cat => 
                `<option value="${cat}" ${transaction.category === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');
            
            expenseOptgroup.innerHTML = categories.expense.map(cat => 
                `<option value="${cat}" ${transaction.category === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');
            
            // Add Uncategorized option
            if (!transaction.category || transaction.category === 'Uncategorized') {
                expenseOptgroup.innerHTML = '<option value="Uncategorized" selected>Uncategorized</option>' + expenseOptgroup.innerHTML;
            } else {
                expenseOptgroup.innerHTML = '<option value="Uncategorized">Uncategorized</option>' + expenseOptgroup.innerHTML;
            }
            
            // Store the transaction ID for saving
            form.setAttribute('data-editing-id', id);
            
            // Scroll to the form
            form.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function saveTransactionEdit() {
            const form = document.getElementById('editTransactionForm');
            const transactionId = form.getAttribute('data-editing-id');
            const transaction = transactions.find(t => t.id === transactionId);
            
            if (!transaction) {
                alert('Transaction not found');
                return;
            }

            // Get form values
            const newDate = document.getElementById('editTransactionDate').value;
            const newDescription = document.getElementById('editTransactionDescription').value.trim();
            const newAmount = parseFloat(document.getElementById('editTransactionAmount').value);
            const newCategory = document.getElementById('editTransactionCategory').value;

            // Validate inputs
            if (!newDate) {
                alert('Please enter a date');
                return;
            }
            if (!newDescription) {
                alert('Please enter a description');
                return;
            }
            if (isNaN(newAmount)) {
                alert('Please enter a valid amount');
                return;
            }
            if (!newCategory) {
                alert('Please select a category');
                return;
            }

            // Update the transaction
            transaction.date = newDate;
            transaction.description = newDescription;
            transaction.amount = newAmount;
            transaction.category = newCategory;
            transaction.lastModified = new Date().toISOString();

            // Update displays and save
            updateDashboard();
            updateTransactionsTable();
            saveUserData();
            
            // Hide the form
            cancelTransactionEdit();
            
            alert('Transaction updated successfully!');
        }

        function cancelTransactionEdit() {
            const form = document.getElementById('editTransactionForm');
            form.classList.add('hidden');
            form.removeAttribute('data-editing-id');
        }

        function deleteTransaction(id) { 
            if (confirm('Delete this transaction?')) {
                transactions = transactions.filter(t => t.id !== id);
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
            }
        }

        function exportData() {
            const dataStr = JSON.stringify({
                transactions,
                categories,
                rules,
                subscriptions,
                exportDate: new Date().toISOString()
            }, null, 2);
            
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `financial-data-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (confirm('This will overwrite your current data. Continue?')) {
                            transactions = data.transactions || [];
                            categories = data.categories || categories;
                            rules = data.rules || [];
                            subscriptions = data.subscriptions || [];
                            
                            updateDashboard();
                            updateTransactionsTable();
                            updateCategoriesView();
                            saveUserData();
                            
                            alert('Data imported successfully!');
                        }
                    } catch (error) {
                        alert('Invalid file format.');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function addSubscription() { 
            const vendor = prompt('Enter vendor/service name:');
            if (!vendor) return;

            const amount = prompt('Enter monthly amount (without $):');
            if (!amount || isNaN(parseFloat(amount))) {
                alert('Please enter a valid amount');
                return;
            }

            const frequency = prompt('Frequency:\n1. Monthly\n2. Quarterly\n3. Annual\nEnter number (1-3):', '1');
            const frequencyMap = {'1': 'monthly', '2': 'quarterly', '3': 'annual'};

            const allCategories = [...categories.expense];
            const categoryIndex = prompt(`Select category:\n${allCategories.map((cat, i) => `${i + 1}. ${cat}`).join('\n')}\nEnter number:`, '1');
            const category = allCategories[parseInt(categoryIndex) - 1] || 'Services';

            const subscription = {
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                vendor: vendor,
                amount: parseFloat(amount),
                frequency: frequencyMap[frequency] || 'monthly',
                category: category,
                status: 'active',
                nextCharge: calculateNextCharge(frequencyMap[frequency] || 'monthly'),
                autoDetected: false,
                created: new Date().toISOString()
            };

            subscriptions.push(subscription);
            updateSubscriptionsView();
            saveUserData();
        }

        function calculateNextCharge(frequency) {
            const now = new Date();
            switch (frequency) {
                case 'monthly':
                    return new Date(now.getFullYear(), now.getMonth() + 1, now.getDate()).toISOString().split('T')[0];
                case 'quarterly':
                    return new Date(now.getFullYear(), now.getMonth() + 3, now.getDate()).toISOString().split('T')[0];
                case 'annual':
                    return new Date(now.getFullYear() + 1, now.getMonth(), now.getDate()).toISOString().split('T')[0];
                default:
                    return new Date(now.getFullYear(), now.getMonth() + 1, now.getDate()).toISOString().split('T')[0];
            }
        }

        function updateSubscriptionsView() {
            const subscriptionsList = document.getElementById('subscriptionsList');
            
            if (subscriptions.length === 0) {
                subscriptionsList.innerHTML = '<p>No subscriptions found. Add subscriptions manually or import transactions to auto-detect them.</p>';
                return;
            }

            // Calculate totals
            const monthlyTotal = subscriptions
                .filter(sub => sub.status === 'active')
                .reduce((total, sub) => {
                    switch (sub.frequency) {
                        case 'monthly': return total + sub.amount;
                        case 'quarterly': return total + (sub.amount / 3);
                        case 'annual': return total + (sub.amount / 12);
                        default: return total + sub.amount;
                    }
                }, 0);

            const annualTotal = monthlyTotal * 12;

            subscriptionsList.innerHTML = `
                <div class="grid" style="margin-bottom: 20px;">
                    <div class="stat-card">
                        <div class="stat-value">${formatCurrency(monthlyTotal)}</div>
                        <div class="stat-label">Monthly Total</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${formatCurrency(annualTotal)}</div>
                        <div class="stat-label">Annual Total</div>
                    </div>
                </div>

                <div class="card">
                    <h4>Active Subscriptions</h4>
                    ${subscriptions.filter(sub => sub.status === 'active').map(sub => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #e2e8f0;">
                            <div>
                                <strong>${sub.vendor}</strong>
                                ${sub.autoDetected ? '<span style="background: #e6fffa; color: #234e52; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">Auto-detected</span>' : ''}
                                ${sub.priceChanged ? '<span style="background: #fed7d7; color: #742a2a; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 5px;">Price Changed</span>' : ''}
                                <br>
                                <small style="color: #718096;">
                                    ${formatCurrency(sub.amount)} ${sub.frequency} ‚Ä¢ ${sub.category}
                                    ${sub.nextCharge ? ` ‚Ä¢ Next: ${formatDate(sub.nextCharge)}` : ''}
                                    ${sub.lastCharge ? ` ‚Ä¢ Last: ${formatDate(sub.lastCharge)}` : ''}
                                </small>
                            </div>
                            <div>
                                <button class="btn btn-secondary" onclick="editSubscription('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Edit</button>
                                <button class="btn" onclick="toggleSubscriptionStatus('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Pause</button>
                                <button class="btn btn-danger" onclick="deleteSubscription('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Delete</button>
                            </div>
                        </div>
                    `).join('')}
                </div>

                ${subscriptions.filter(sub => sub.status !== 'active').length > 0 ? `
                    <div class="card">
                        <h4>Paused/Cancelled Subscriptions</h4>
                        ${subscriptions.filter(sub => sub.status !== 'active').map(sub => `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #e2e8f0; opacity: 0.7;">
                                <div>
                                    <strong>${sub.vendor}</strong>
                                    <span style="background: #f7fafc; color: #4a5568; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">${sub.status}</span>
                                    <br>
                                    <small style="color: #718096;">
                                        ${formatCurrency(sub.amount)} ${sub.frequency} ‚Ä¢ ${sub.category}
                                    </small>
                                </div>
                                <div>
                                    <button class="btn btn-secondary" onclick="editSubscription('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Edit</button>
                                    <button class="btn" onclick="toggleSubscriptionStatus('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Reactivate</button>
                                    <button class="btn btn-danger" onclick="deleteSubscription('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Delete</button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            `;
        }

        function editSubscription(subscriptionId) {
            const subscription = subscriptions.find(sub => sub.id === subscriptionId);
            if (!subscription) return;

            const newVendor = prompt('Edit vendor name:', subscription.vendor);
            if (newVendor !== null) subscription.vendor = newVendor;

            const newAmount = prompt('Edit amount:', subscription.amount);
            if (newAmount !== null && !isNaN(parseFloat(newAmount))) {
                subscription.amount = parseFloat(newAmount);
            }

            const frequency = prompt('Frequency:\n1. Monthly\n2. Quarterly\n3. Annual\nEnter number (1-3):', 
                subscription.frequency === 'monthly' ? '1' : 
                subscription.frequency === 'quarterly' ? '2' : '3');
            const frequencyMap = {'1': 'monthly', '2': 'quarterly', '3': 'annual'};
            if (frequencyMap[frequency]) {
                subscription.frequency = frequencyMap[frequency];
                subscription.nextCharge = calculateNextCharge(subscription.frequency);
            }

            const allCategories = [...categories.expense];
            const currentIndex = allCategories.indexOf(subscription.category) + 1;
            const categoryIndex = prompt(`Select category:\n${allCategories.map((cat, i) => `${i + 1}. ${cat}`).join('\n')}\nEnter number:`, currentIndex.toString());
            const category = allCategories[parseInt(categoryIndex) - 1];
            if (category) subscription.category = category;

            updateSubscriptionsView();
            saveUserData();
        }

        function toggleSubscriptionStatus(subscriptionId) {
            const subscription = subscriptions.find(sub => sub.id === subscriptionId);
            if (!subscription) return;

            subscription.status = subscription.status === 'active' ? 'paused' : 'active';
            if (subscription.status === 'active') {
                subscription.nextCharge = calculateNextCharge(subscription.frequency);
            }

            updateSubscriptionsView();
            saveUserData();
        }

        function deleteSubscription(subscriptionId) {
            if (confirm('Delete this subscription?')) {
                subscriptions = subscriptions.filter(sub => sub.id !== subscriptionId);
                updateSubscriptionsView();
                saveUserData();
            }
        }
        function addRule() { 
            toggleAddRuleForm();
        }

        function toggleAddRuleForm() {
            const form = document.getElementById('addRuleForm');
            const isHidden = form.classList.contains('hidden');
            
            if (isHidden) {
                // Show the form and populate categories
                form.classList.remove('hidden');
                populateRuleCategoryDropdown();
                // Clear any previous values
                document.getElementById('newRuleName').value = '';
                document.getElementById('newRuleConditionValue').value = '';
                document.getElementById('newRuleConditionType').value = 'contains';
            } else {
                // Hide the form
                form.classList.add('hidden');
            }
        }

        function populateRuleCategoryDropdown() {
            const select = document.getElementById('newRuleCategory');
            const incomeOptgroup = select.querySelector('optgroup[label="Income Categories"]');
            const expenseOptgroup = select.querySelector('optgroup[label="Expense Categories"]');
            
            incomeOptgroup.innerHTML = categories.income.map(cat => 
                `<option value="${cat}">${cat}</option>`
            ).join('');
            
            expenseOptgroup.innerHTML = categories.expense.map(cat => 
                `<option value="${cat}">${cat}</option>`
            ).join('');
        }

        function saveNewRule() {
            const name = document.getElementById('newRuleName').value.trim();
            const conditionType = document.getElementById('newRuleConditionType').value;
            const conditionValue = document.getElementById('newRuleConditionValue').value.trim();
            const category = document.getElementById('newRuleCategory').value;

            // Validate inputs
            if (!name) {
                alert('Please enter a rule name');
                return;
            }
            if (!conditionValue) {
                alert('Please enter text to match');
                return;
            }
            if (!category) {
                alert('Please select a category');
                return;
            }

            const rule = {
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                name: name,
                conditions: [{
                    type: conditionType,
                    value: conditionValue
                }],
                category: category,
                active: true,
                created: new Date().toISOString()
            };

            rules.push(rule);
            updateRulesView();
            saveUserData();
            
            // Hide the form
            document.getElementById('addRuleForm').classList.add('hidden');
            
            // Show success message
            alert(`Rule "${name}" created successfully!`);
        }

        function cancelAddRule() {
            document.getElementById('addRuleForm').classList.add('hidden');
        }

        function updateRulesView() {
            const rulesList = document.getElementById('rulesList');
            
            rulesList.innerHTML = rules.length ? rules.map(rule => `
                <div class="card" style="margin-bottom: 15px; ${!rule.active ? 'opacity: 0.6;' : ''}">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0; color: ${rule.active ? '#4a5568' : '#a0aec0'};">${rule.name}</h4>
                            <p style="margin: 5px 0; font-size: 0.9em; color: #718096;">
                                If description <strong>${rule.conditions[0].type.replace('_', ' ')}</strong> 
                                "<strong>${rule.conditions[0].value}</strong>" ‚Üí 
                                Set category to <strong>${rule.category}</strong>
                            </p>
                            <small style="color: #a0aec0;">Created: ${formatDate(rule.created)}</small>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn ${rule.active ? 'btn-secondary' : ''}" onclick="toggleRule('${rule.id}')" style="padding: 8px 12px;">
                                ${rule.active ? 'Disable' : 'Enable'}
                            </button>
                            <button class="btn btn-secondary" onclick="editRule('${rule.id}')" style="padding: 8px 12px;">Edit</button>
                            <button class="btn btn-danger" onclick="deleteRule('${rule.id}')" style="padding: 8px 12px;">Delete</button>
                        </div>
                    </div>
                </div>
            `).join('') : '<p>No rules created yet. Rules help automatically categorize transactions based on description patterns.</p>';
        }

        function toggleRule(ruleId) {
            const rule = rules.find(r => r.id === ruleId);
            if (rule) {
                rule.active = !rule.active;
                updateRulesView();
                saveUserData();
            }
        }

        function editRule(ruleId) {
            const rule = rules.find(r => r.id === ruleId);
            if (!rule) return;

            // Show the edit form (we'll reuse the add form)
            const form = document.getElementById('addRuleForm');
            form.classList.remove('hidden');
            populateRuleCategoryDropdown();
            
            // Populate with existing values
            document.getElementById('newRuleName').value = rule.name;
            document.getElementById('newRuleConditionType').value = rule.conditions[0].type;
            document.getElementById('newRuleConditionValue').value = rule.conditions[0].value;
            document.getElementById('newRuleCategory').value = rule.category;
            
            // Change the save button to update
            const saveButton = form.querySelector('.btn[onclick="saveNewRule()"]');
            saveButton.textContent = 'Update Rule';
            saveButton.setAttribute('onclick', `updateRule('${ruleId}')`);
            
            // Change the form title
            form.querySelector('h4').textContent = 'Edit Rule';
        }

        function updateRule(ruleId) {
            const rule = rules.find(r => r.id === ruleId);
            if (!rule) return;

            const name = document.getElementById('newRuleName').value.trim();
            const conditionType = document.getElementById('newRuleConditionType').value;
            const conditionValue = document.getElementById('newRuleConditionValue').value.trim();
            const category = document.getElementById('newRuleCategory').value;

            // Validate inputs
            if (!name || !conditionValue || !category) {
                alert('Please fill in all fields');
                return;
            }

            // Update the rule
            rule.name = name;
            rule.conditions[0].type = conditionType;
            rule.conditions[0].value = conditionValue;
            rule.category = category;
            rule.updated = new Date().toISOString();

            updateRulesView();
            saveUserData();
            
            // Reset the form
            resetAddRuleForm();
            
            alert(`Rule "${name}" updated successfully!`);
        }

        function resetAddRuleForm() {
            const form = document.getElementById('addRuleForm');
            form.classList.add('hidden');
            
            // Reset the button and title
            const saveButton = form.querySelector('.btn[onclick*="Rule"]');
            saveButton.textContent = 'Save Rule';
            saveButton.setAttribute('onclick', 'saveNewRule()');
            form.querySelector('h4').textContent = 'Create New Rule';
        }

        function deleteRule(ruleId) {
            const rule = rules.find(r => r.id === ruleId);
            if (!rule) return;
            
            if (confirm(`Delete rule "${rule.name}"?`)) {
                rules = rules.filter(r => r.id !== ruleId);
                updateRulesView();
                saveUserData();
            }
        }

        function applyRulesToExistingTransactions() {
            if (!confirm('Apply current rules to all existing transactions? This will update categories for matching transactions.')) {
                return;
            }

            let updatedCount = 0;
            transactions.forEach(transaction => {
                const originalCategory = transaction.category;
                const newCategory = applyCategorationRules(transaction.description, originalCategory);
                if (newCategory !== originalCategory) {
                    transaction.category = newCategory;
                    updatedCount++;
                }
            });

            if (updatedCount > 0) {
                alert(`Updated ${updatedCount} transactions based on current rules.`);
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
            } else {
                alert('No transactions were updated. Rules may not match any existing transactions.');
            }
        }

        // Initialize the dashboard
        updateDashboard();
        updateCategoriesView();
        updateRulesView();
        updateSubscriptionsView();
    </script>
</body>
</html>
