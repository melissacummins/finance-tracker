<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Financial Management System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }

        .nav-tabs {
            display: flex;
            background: white;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .nav-tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-tab.active {
            background: #667eea;
            color: white;
        }

        .nav-tab:hover:not(.active) {
            background: #f0f2f5;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.1);
        }

        .card h3 {
            color: #4a5568;
            margin-bottom: 20px;
            font-size: 1.2em;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn-secondary {
            background: #718096;
        }

        .btn-secondary:hover {
            background: #4a5568;
        }

        .btn-danger {
            background: #e53e3e;
        }

        .btn-danger:hover {
            background: #c53030;
        }

        .btn-warning {
            background: #f59e0b;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #4a5568;
        }

        .form-control {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
        }

        .grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .table th,
        .table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .table th {
            background: #f7fafc;
            font-weight: 600;
            color: #4a5568;
        }

        .table tr:hover {
            background: #f7fafc;
        }

        .upload-area {
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f7fafc;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            opacity: 0.9;
            font-size: 0.9em;
        }

        .variance-card {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .variance-positive {
            border-color: #059669;
            background: #f0fff4;
        }

        .variance-negative {
            border-color: #dc2626;
            background: #fef2f2;
        }

        .projection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .projection-card {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid;
        }

        .projection-baseline {
            background: #f7fafc;
            border-color: #4a5568;
            color: #4a5568;
        }

        .projection-conservative {
            background: #fef2f2;
            border-color: #dc2626;
            color: #dc2626;
            position: relative;
        }

        .projection-conservative::after {
            content: "🎯 TARGET";
            position: absolute;
            top: -8px;
            right: -8px;
            background: #dc2626;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 0.6em;
            font-weight: bold;
        }

        .projection-optimistic {
            background: #f0fff4;
            border-color: #059669;
            color: #059669;
        }

        .seasonal-manager {
            background: #fff8e1;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .hidden {
            display: none !important;
        }

        .edit-form {
            background: #fff8e1;
            border: 2px solid #ffc107;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .alias-tag {
            display: inline-block;
            background: #e2e8f0;
            color: #4a5568;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            margin: 2px;
        }
.duplicate-panel {
            background: #fffbeb;
            border: 2px solid #f59e0b;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .duplicate-group {
            background: white;
            border: 1px solid #fbbf24;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .duplicate-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #fef3c7;
        }

        .duplicate-item:last-child {
            border-bottom: none;
        }

        .duplicate-item:hover {
            background: #fef3c7;
        }
        
        .suggested-alias {
            background: #fef3cd;
            color: #92400e;
            border: 1px dashed #f59e0b;
        }

        .merge-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .merge-dialog-content {
            background: white;
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .subscription-item {
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .subscription-item:hover {
            border-color: #667eea;
            background: #f7fafc;
        }

        .subscription-item.selected {
            border-color: #667eea;
            background: #e6fffa;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .nav-tabs {
                flex-direction: column;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .header > div {
                flex-direction: column !important;
                text-align: center !important;
            }

            .merge-dialog-content {
                padding: 20px;
                margin: 10px;
            }
        }
        .sortable-header {
    cursor: pointer;
    user-select: none;
    position: relative;
    padding-right: 20px;
}

.sortable-header:hover {
    background: #e6f2ff;
}

.sortable-header::after {
    content: '↕';
    position: absolute;
    right: 5px;
    opacity: 0.3;
}

.sortable-header.sort-asc::after {
    content: '↑';
    opacity: 1;
}

.sortable-header.sort-desc::after {
    content: '↓';
    opacity: 1;
}

.manual-archive-btn {
    background: #f59e0b;
    margin-left: 10px;
}

.manual-archive-btn:hover {
    background: #d97706;
}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h1>Financial Management System</h1>
                    <p>Import, categorize, and analyze your transactions with automated rules and income variance projections</p>
                </div>
                <div id="authContainer">
                    <div id="signedOutContainer">
                        <button class="btn" onclick="signInWithGoogle()" style="background: #4285f4;">
                            🔐 Sign in with Google
                        </button>
                    </div>
                    <div id="signedInContainer" style="display: none;">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="text-align: right;">
                                <div id="userDisplayName" style="font-weight: bold;"></div>
                                <div id="userEmail" style="font-size: 0.9em; opacity: 0.9;"></div>
                            </div>
                            <img id="userPhoto" style="width: 40px; height: 40px; border-radius: 50%; border: 2px solid white;">
                            <button class="btn btn-secondary" onclick="signOutUser()">Sign Out</button>
                        </div>
                    </div>
                </div>
            </div>
            <div id="syncStatus" style="margin-top: 10px; text-align: center; font-size: 0.9em; opacity: 0.9;">
                Sign in to sync data to the cloud
            </div>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('dashboard')">Dashboard</button>
            <button class="nav-tab" onclick="showTab('import')">Import Data</button>
            <button class="nav-tab" onclick="showTab('transactions')">Transactions</button>
            <button class="nav-tab" onclick="showTab('categories')">Categories</button>
            <button class="nav-tab" onclick="showTab('subscriptions')">Subscriptions</button>
            <button class="nav-tab" onclick="showTab('cashflow')">Cash Flow</button>
            <button class="nav-tab" onclick="showTab('rules')">Rules</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard" class="tab-content active">
            <div class="dashboard-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalIncome">$0</div>
                    <div class="stat-label">Total Income</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalExpenses">$0</div>
                    <div class="stat-label">Total Expenses</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="netCashFlow">$0</div>
                    <div class="stat-label">Net Cash Flow</div>
                </div>
                <div class="stat-card" onclick="showUncategorizedTransactions()" style="cursor: pointer;" title="Click to view uncategorized transactions">
                    <div class="stat-value" id="uncategorizedCount">0</div>
                    <div class="stat-label">Uncategorized Transactions</div>
                </div>
            </div>

            <div class="grid">
                <div class="card">
                    <h3>Recent Activity</h3>
                    <div id="recentTransactions">
                        <p>No transactions yet. Start by importing data or adding transactions manually.</p>
                    </div>
                </div>
                <div class="card">
                    <h3>Category Breakdown</h3>
                    <div id="categoryBreakdown">
                        <p>Categories will appear here once you add transactions.</p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Quick Actions</h3>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn" onclick="showTab('import')">Import Transactions</button>
                    <button class="btn btn-secondary" onclick="exportData()">Export Data</button>
                    <button class="btn btn-secondary" onclick="importData()">Import Data</button>
                </div>
            </div>
        </div>

        <!-- Import Data Tab -->
        <div id="import" class="tab-content">
            <div class="card">
                <h3>Import Transactions</h3>
                
                <div class="upload-area" id="uploadArea">
                    <p>Drag & drop your CSV/Excel file here or click to browse</p>
                    <input type="file" id="fileInput" accept=".csv,.xlsx,.xls" style="display: none;">
                </div>

                <div id="mappingSection" class="hidden">
                    <h4>Column Mapping</h4>
                    <p>Map your file columns to the appropriate fields:</p>
                    
                    <div id="columnMapping" style="margin: 20px 0;"></div>

                    <div class="form-group">
                        <label>Account Type</label>
                        <select id="accountType" class="form-control">
                            <option value="checking">Checking Account</option>
                            <option value="credit">Credit Card</option>
                            <option value="savings">Savings Account</option>
                        </select>
                    </div>

                    <button class="btn" onclick="processImport()">Import Transactions</button>
                </div>
            </div>
        </div>

        <!-- Transactions Tab -->
        <div id="transactions" class="tab-content">
            <div class="card">
                <h3>All Transactions</h3>

                <div style="margin-bottom: 15px;">
                    <button class="btn" onclick="showAddTransactionForm()">+ Add New Transaction</button>
                </div>

                <div class="form-group">
                    <input type="text" id="transactionSearch" class="form-control" placeholder="Search transactions...">
                </div>

                <div class="form-group">
                    <select id="categoryFilter" class="form-control">
                        <option value="">All Categories</option>
                        <option value="uncategorized">Uncategorized Only</option>
                    </select>
                </div>

                <!-- Bulk Actions -->
                <div id="bulkActions" class="hidden" style="background: #f7fafc; padding: 15px; border-radius: 6px; margin-bottom: 15px; border: 2px solid #e2e8f0;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span id="selectedCount">0 transactions selected</span>
                        <div style="display: flex; gap: 10px;">
                            <select id="bulkCategorySelect" class="form-control" style="width: 200px;">
                                <option value="">Choose category...</option>
                            </select>
                            <button class="btn" onclick="bulkSetCategory()">Set Category</button>
                            <button class="btn btn-danger" onclick="bulkDeleteTransactions()">Delete Selected</button>
                            <button class="btn btn-secondary" onclick="clearSelection()">Clear Selection</button>
                        </div>
                    </div>
                </div>

                <!-- Add Transaction Form -->
                <div id="addTransactionForm" class="card hidden" style="background: #e8f5e9; border: 2px solid #4caf50; margin-bottom: 15px;">
                    <h4>Add New Transaction</h4>
                    <div class="grid">
                        <div class="form-group">
                            <label>Date</label>
                            <input type="date" id="addTransactionDate" class="form-control">
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="number" step="0.01" id="addTransactionAmount" class="form-control" placeholder="Negative for expenses, positive for income">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <input type="text" id="addTransactionDescription" class="form-control" placeholder="Enter transaction description">
                    </div>
                    <div class="form-group">
                        <label>Category</label>
                        <select id="addTransactionCategory" class="form-control">
                            <optgroup label="Income Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                            <optgroup label="Expense Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn" onclick="saveNewTransaction()">Add Transaction</button>
                        <button class="btn btn-secondary" onclick="cancelAddTransaction()">Cancel</button>
                    </div>
                </div>

                <!-- Edit Transaction Form -->
                <div id="editTransactionForm" class="card hidden" style="background: #fff8e1; border: 2px solid #ffc107; margin-bottom: 15px;">
                    <h4>Edit Transaction</h4>
                    <div class="grid">
                        <div class="form-group">
                            <label>Date</label>
                            <input type="date" id="editTransactionDate" class="form-control">
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="number" step="0.01" id="editTransactionAmount" class="form-control">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <input type="text" id="editTransactionDescription" class="form-control">
                    </div>
                    <div class="form-group">
                        <label>Category</label>
                        <select id="editTransactionCategory" class="form-control">
                            <optgroup label="Income Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                            <optgroup label="Expense Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn" onclick="saveTransactionEdit()">Save Changes</button>
                        <button class="btn btn-secondary" onclick="cancelTransactionEdit()">Cancel</button>
                    </div>
                </div>

                <table class="table" id="transactionsTable">
                  <thead>
    <tr>
        <th><input type="checkbox" id="selectAllTransactions" onchange="toggleSelectAll()"></th>
        <th class="sortable-header" data-column="date" onclick="sortTransactions('date')">Date</th>
        <th class="sortable-header" data-column="description" onclick="sortTransactions('description')">Description</th>
        <th class="sortable-header" data-column="amount" onclick="sortTransactions('amount')">Amount</th>
        <th class="sortable-header" data-column="category" onclick="sortTransactions('category')">Category</th>
        <th>Actions</th>
    </tr>
</thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <!-- Categories Tab -->
        <div id="categories" class="tab-content">
            <div class="grid">
                <div class="card">
                    <h3>Income Categories</h3>
                    
                    <!-- Add Income Category Form -->
                    <div id="addIncomeCategoryForm" class="hidden" style="background: #f0fff4; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <div class="form-group">
                            <input type="text" id="newIncomeCategory" class="form-control" placeholder="Enter income category name">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="saveNewCategory('income')">Add Category</button>
                            <button class="btn btn-secondary" onclick="cancelAddCategory('income')">Cancel</button>
                        </div>
                    </div>
                    
                    <div id="incomeCategories"></div>
                    <button class="btn" onclick="toggleAddCategoryForm('income')">Add Income Category</button>
                </div>
                <div class="card">
                    <h3>Expense Categories</h3>
                    
                    <!-- Add Expense Category Form -->
                    <div id="addExpenseCategoryForm" class="hidden" style="background: #fff5f5; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <div class="form-group">
                            <input type="text" id="newExpenseCategory" class="form-control" placeholder="Enter expense category name">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" onclick="saveNewCategory('expense')">Add Category</button>
                            <button class="btn btn-secondary" onclick="cancelAddCategory('expense')">Cancel</button>
                        </div>
                    </div>
                    
                    <div id="expenseCategories"></div>
                    <button class="btn" onclick="toggleAddCategoryForm('expense')">Add Expense Category</button>
                </div>
            </div>
        </div>

        <!-- Subscriptions Tab -->
        <div id="subscriptions" class="tab-content">
            <div class="card">
                <h3>📄 Subscription Management with Smart Matching</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="btn" onclick="toggleAddSubscriptionForm()">Add Subscription</button>
                    <button class="btn btn-secondary" onclick="showMergeManager()">Merge Subscriptions</button>
                    <button class="btn btn-warning" onclick="reviewSuggestedAliases()">Review Suggested Aliases</button>
                </div>

                <!-- Add Subscription Form -->
                <div id="addSubscriptionForm" class="card hidden" style="background: #f0fff4; border: 2px solid #059669; margin-bottom: 20px;">
                    <h4>Add New Subscription</h4>
                    <div class="grid">
                        <div class="form-group">
                            <label>Vendor/Service Name *</label>
                            <input type="text" id="newSubVendor" class="form-control" placeholder="e.g., Netflix, Spotify">
                        </div>
                        <div class="form-group">
                            <label>Amount *</label>
                            <input type="number" id="newSubAmount" class="form-control" step="0.01" placeholder="0.00">
                        </div>
                    </div>
                    <div class="grid">
                        <div class="form-group">
                            <label>Frequency *</label>
                            <select id="newSubFrequency" class="form-control">
                                <option value="monthly">Monthly</option>
                                <option value="quarterly">Quarterly</option>
                                <option value="annual">Annual</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Category *</label>
                            <select id="newSubCategory" class="form-control">
                                <!-- Will be populated with expense categories -->
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Aliases (optional, comma-separated)</label>
                        <input type="text" id="newSubAliases" class="form-control" placeholder="e.g., NFLX, Netflix.com, Netflix Inc">
                        <small style="color: #718096;">Alternative names that might appear on your statement</small>
                    </div>
                    <div class="form-group">
                        <label>Matching Pattern (optional, for descriptions with random characters)</label>
                        <div class="grid">
                            <select id="newSubPatternType" class="form-control">
                                <option value="">No pattern</option>
                                <option value="contains">Contains</option>
                                <option value="starts_with">Starts with</option>
                                <option value="ends_with">Ends with</option>
                                <option value="equals">Equals</option>
                            </select>
                            <input type="text" id="newSubPatternValue" class="form-control" placeholder="e.g., Kindle Unltd">
                        </div>
                        <small style="color: #718096;">Use this to match descriptions like "Kindle Unltd*N43Z31ID1" - set pattern to "starts with" and value to "Kindle Unltd"</small>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn" onclick="saveNewSubscription()">Save Subscription</button>
                        <button class="btn btn-secondary" onclick="cancelAddSubscription()">Cancel</button>
                    </div>
                </div>

                <!-- Edit Subscription Form -->
                <div id="editSubscriptionForm" class="card hidden" style="background: #fff8e1; border: 2px solid #ffc107; margin-bottom: 20px;">
                    <h4>Edit Subscription</h4>
                    <div class="grid">
                        <div class="form-group">
                            <label>Vendor/Service Name *</label>
                            <input type="text" id="editSubVendor" class="form-control">
                        </div>
                        <div class="form-group">
                            <label>Amount *</label>
                            <input type="number" id="editSubAmount" class="form-control" step="0.01">
                        </div>
                    </div>
                    <div class="grid">
                        <div class="form-group">
                            <label>Frequency *</label>
                            <select id="editSubFrequency" class="form-control">
                                <option value="monthly">Monthly</option>
                                <option value="quarterly">Quarterly</option>
                                <option value="annual">Annual</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Category *</label>
                            <select id="editSubCategory" class="form-control">
                                <!-- Will be populated with expense categories -->
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Aliases (comma-separated)</label>
                        <input type="text" id="editSubAliases" class="form-control">
                        <small style="color: #718096;">Alternative names that might appear on your statement</small>
                    </div>
                    <div class="form-group">
                        <label>Matching Pattern (optional, for descriptions with random characters)</label>
                        <div class="grid">
                            <select id="editSubPatternType" class="form-control">
                                <option value="">No pattern</option>
                                <option value="contains">Contains</option>
                                <option value="starts_with">Starts with</option>
                                <option value="ends_with">Ends with</option>
                                <option value="equals">Equals</option>
                            </select>
                            <input type="text" id="editSubPatternValue" class="form-control" placeholder="e.g., Kindle Unltd">
                        </div>
                        <small style="color: #718096;">Use this to match descriptions like "Kindle Unltd*N43Z31ID1" - set pattern to "starts with" and value to "Kindle Unltd"</small>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn" onclick="saveSubscriptionEdit()">Save Changes</button>
                        <button class="btn btn-secondary" onclick="cancelEditSubscription()">Cancel</button>
                    </div>
                </div>
                
                <div id="subscriptionsList"></div>
            </div>
        </div>

        <!-- Cash Flow Tab -->
        <div id="cashflow" class="tab-content">
            <!-- Seasonal Factor Manager -->
            <div class="seasonal-manager">
                <h3>📅 Seasonal Factor Manager</h3>
                <p>Adjust seasonal factors to fine-tune your income projections. Higher factors for peak months, lower for slower months.</p>
                
                <div class="grid">
                    <div class="form-group">
                        <label>Current Month Factor</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="currentSeasonalFactor" class="form-control" step="0.1" min="0.1" max="3.0" placeholder="1.0">
                            <button class="btn" onclick="updateCurrentSeasonalFactor()">Update</button>
                        </div>
                        <small style="color: #718096;">Current: <span id="currentSeasonalFactorDisplay">1.0</span> | 1.0 = normal, 1.5 = 50% above average, 0.7 = 30% below average</small>
                    </div>
                    <div class="form-group">
                        <label>Quick Presets</label>
                        <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                            <button class="btn btn-secondary" onclick="setSeasonalFactor(0.7)">Low (0.7)</button>
                            <button class="btn btn-secondary" onclick="setSeasonalFactor(1.0)">Normal (1.0)</button>
                            <button class="btn btn-secondary" onclick="setSeasonalFactor(1.3)">High (1.3)</button>
                            <button class="btn btn-secondary" onclick="setSeasonalFactor(1.5)">Peak (1.5)</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Income Variance Analysis -->
            <div class="card">
                <h3>📊 Income Variance & Projections</h3>
                <div style="margin-bottom: 15px; padding: 10px; background: #fff8e1; border-radius: 6px; border: 1px solid #f59e0b;">
    <span style="font-weight: bold; color: #92400e;">💾 Archive Current Month:</span>
    <button class="btn manual-archive-btn" onclick="manuallyArchiveCurrentMonth()" style="padding: 8px 16px;">
        Archive Now
    </button>
    <small style="display: block; margin-top: 5px; color: #92400e;">
        Manually save current month's data to projection history (normally happens automatically at month-end)
    </small>
</div>
                
                <div id="incomeVarianceDisplay">
                    <div class="variance-card" id="varianceCard">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <div>
                                <h4 style="margin: 0; color: #4a5568;">12-Month Rolling Average</h4>
                                <div style="font-size: 0.8em; color: #718096; margin-bottom: 5px;">
                                    (Available data: <span id="availableMonthsCount">0</span> months)
                                </div>
                                <div style="font-size: 2em; font-weight: bold; margin: 5px 0;" id="rollingAverage">$0</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 0.9em; color: #718096;">Current Month Progress</div>
                                <div style="font-size: 1.5em; font-weight: bold;" id="currentMonthIncome">$0</div>
                                <div style="font-size: 1.2em;" id="variancePercentage">0%</div>
                            </div>
                        </div>
                        
                        <div class="projection-grid">
                            <div class="projection-card projection-conservative">
                                <div style="font-weight: bold; margin-bottom: 5px;">Conservative</div>
                                <div style="font-size: 1.3em;" id="conservativeProjection">$0</div>
                                <div style="font-size: 0.8em; opacity: 0.8;">-25% of baseline</div>
                                <div style="font-size: 0.7em; margin-top: 5px; font-weight: bold;">🎯 MONTHLY TARGET</div>
                            </div>
                            <div class="projection-card projection-baseline">
                                <div style="font-weight: bold; margin-bottom: 5px;">Baseline</div>
                                <div style="font-size: 1.3em;" id="baselineProjection">$0</div>
                                <div style="font-size: 0.8em; opacity: 0.8;">12-month avg + seasonal</div>
                            </div>
                            <div class="projection-card projection-optimistic">
                                <div style="font-weight: bold; margin-bottom: 5px;">Optimistic</div>
                                <div style="font-size: 1.3em;" id="optimisticProjection">$0</div>
                                <div style="font-size: 0.8em; opacity: 0.8;">+25% of baseline</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <h4>Month-to-Date Performance vs Conservative Target</h4>
                    <div id="monthlyProgressBar">
                        <!-- Progress bar will be inserted here -->
                    </div>
                </div>
            </div>

            <!-- Projection History Management -->
            <div class="card">
                <h3>📈 Projection Accuracy Tracking</h3>
                <p>Manually enter past month projections and actuals to track forecasting accuracy over time.</p>
                
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="btn" onclick="showAddProjectionForm()">Add Historical Month</button>
                    <button class="btn btn-secondary" onclick="importProjectionData()">Import from CSV</button>
                    <button class="btn btn-secondary" onclick="exportProjectionData()">Export Data</button>
                </div>

                <!-- Add Projection Form -->
                <div id="addProjectionForm" class="card hidden" style="background: #f0fff4; border: 2px solid #059669; margin-bottom: 20px;">
                    <h4>Add Historical Projection Data</h4>
                    <div class="grid">
                        <div class="form-group">
                            <label>Month & Year</label>
                            <input type="month" id="projectionMonth" class="form-control">
                        </div>
                        <div class="form-group">
                            <label>Seasonal Factor</label>
                            <input type="number" id="projectionSeasonalFactor" class="form-control" step="0.1" min="0.1" max="3.0" placeholder="1.0">
                        </div>
                    </div>
                    <div class="grid">
                        <div class="form-group">
                            <label>Baseline Projection</label>
                            <input type="number" id="projectionBaseline" class="form-control" step="0.01" placeholder="0.00">
                        </div>
                        <div class="form-group">
                            <label>Actual Income</label>
                            <input type="number" id="projectionActual" class="form-control" step="0.01" placeholder="0.00">
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn" onclick="saveProjectionData()">Save Data</button>
                        <button class="btn btn-secondary" onclick="cancelAddProjection()">Cancel</button>
                    </div>
                </div>

                <!-- Projection History Table -->
                <div id="projectionHistoryTable">
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Month</th>
                                <th>Seasonal Factor</th>
                                <th>Conservative</th>
                                <th>Baseline</th>
                                <th>Optimistic</th>
                                <th>Actual</th>
                                <th>vs Conservative Target</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="projectionHistoryBody">
                            <!-- Will be populated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="grid">
                <div class="card">
                    <h3>Income vs Expenses</h3>
                    <div id="incomeVsExpensesChart">
                        <!-- Income vs expenses breakdown will be displayed here -->
                    </div>
                </div>
                <div class="card">
                    <h3>Running Balance</h3>
                    <div id="runningBalanceChart">
                        <!-- Running balance chart will be displayed here -->
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>Historical Seasonal Factors</h3>
                <div id="seasonalFactorHistory">
                    <!-- Historical seasonal factors will be displayed here -->
                </div>
            </div>
        </div>

        <!-- Rules Tab -->
        <div id="rules" class="tab-content">
            <div class="card">
                <h3>Categorization Rules</h3>
                <p>Create rules to automatically categorize transactions based on description patterns. Rules are applied in order when importing new transactions.</p>
                
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn" onclick="toggleAddRuleForm()">Add New Rule</button>
                    <button class="btn btn-secondary" onclick="applyRulesToExistingTransactions()">Apply Rules to Existing Transactions</button>
                </div>
                
                <!-- Add Rule Form -->
                <div id="addRuleForm" class="card hidden" style="background: #f7fafc; border: 2px solid #e2e8f0;">
                    <h4>Create New Rule</h4>
                    <div class="grid">
                        <div class="form-group">
                            <label>Rule Name</label>
                            <input type="text" id="newRuleName" class="form-control" placeholder="e.g., Netflix Subscription">
                        </div>
                        <div class="form-group">
                            <label>If Description</label>
                            <select id="newRuleConditionType" class="form-control">
                                <option value="contains">Contains</option>
                                <option value="starts_with">Starts With</option>
                                <option value="ends_with">Ends With</option>
                                <option value="equals">Equals Exactly</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Text to Match</label>
                        <input type="text" id="newRuleConditionValue" class="form-control" placeholder="e.g., NETFLIX">
                    </div>
                    <div class="form-group">
                        <label>Then Set Category To</label>
                        <select id="newRuleCategory" class="form-control">
                            <optgroup label="Income Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                            <optgroup label="Expense Categories">
                                <!-- Will be populated dynamically -->
                            </optgroup>
                        </select>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button class="btn" onclick="saveNewRule()">Save Rule</button>
                        <button class="btn btn-secondary" onclick="cancelAddRule()">Cancel</button>
                    </div>
                </div>
                
                <div id="rulesList"></div>
            </div>
        </div>
    </div>

    <!-- Merge Dialog -->
    <div id="mergeDialog" class="merge-dialog hidden">
        <div class="merge-dialog-content">
            <h3>🔄 Merge Subscriptions</h3>
            <p>Select subscriptions to merge. The first selected will be the primary subscription.</p>
            
            <div id="mergeSubscriptionsList"></div>
            
            <div class="form-group">
                <label>Add Alias (optional)</label>
                <input type="text" id="newAliasInput" class="form-control" placeholder="Enter alternative name for this subscription">
                <small style="color: #718096;">Aliases help match future transactions with different but similar descriptions</small>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn" onclick="executeMerge()" id="mergeBtn" disabled>Merge Selected</button>
                <button class="btn btn-secondary" onclick="closeMergeDialog()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Alias Review Dialog -->
    <div id="aliasDialog" class="merge-dialog hidden">
        <div class="merge-dialog-content">
            <h3>🔍 Review Suggested Aliases</h3>
            <p>These aliases were automatically suggested based on similar transaction descriptions:</p>
            
            <div id="suggestedAliasesList"></div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-secondary" onclick="closeAliasDialog()">Close</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK v9 -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, addDoc, updateDoc, deleteDoc, query, where, getDocs, orderBy } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
        
        const firebaseConfig = {
            apiKey: "AIzaSyCfcKmWAg7rnxVao5hNfgexb8FfPkwu2ww",
            authDomain: "income-expenses-cash-flow.firebaseapp.com",
            projectId: "income-expenses-cash-flow",
            storageBucket: "income-expenses-cash-flow.firebasestorage.app",
            messagingSenderId: "489754288851",
            appId: "1:489754288851:web:a8151822e2066535746a26",
            measurementId: "G-72Q1KQ4TFR"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();
        provider.addScope('email');
        provider.addScope('profile');
        
        window.firebaseServices = {
            auth, db, provider, signInWithPopup, signOut, onAuthStateChanged,
            doc, setDoc, getDoc, collection, addDoc, updateDoc, deleteDoc, 
            query, where, getDocs, orderBy
        };
        
        window.dispatchEvent(new Event('firebaseReady'));
    </script>

    <script>
        // Global data storage
        let transactions = [];
        let categories = {
            income: ['Direct Sales', 'Amazon', 'Kobo', 'Draft2Digital', 'Google Play', 'Patreon', 'Findaway', 'Kickstarter'],
            expense: ['Services', 'Shipping', 'Production', 'Marketing', 'Education', 'Business']
        };
        let rules = [];
        let subscriptions = [];
        let seasonalFactors = {}; // Store monthly seasonal factors
        let projectionHistory = {}; // Store historical projections and actuals for accuracy tracking
        let currentUser = null;
        let firebaseReady = false;

        // Add sorting state (add this with other global variables at top of script)
let transactionSort = {
    column: 'date',
    direction: 'desc' // newest first by default
};

// Auto-archive completed months
function checkAndArchiveCompletedMonths() {
    const now = new Date();
    const currentMonthKey = getCurrentMonthKey();
    
    // Get all months that have income transactions
    const incomeTransactions = transactions.filter(t => t.amount > 0 && !t.excludeFromTotals);
    const monthsWithIncome = {};
    
    incomeTransactions.forEach(t => {
        const date = new Date(t.date);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        monthsWithIncome[monthKey] = (monthsWithIncome[monthKey] || 0) + t.amount;
    });
    
    // Check for completed months (not current month and not already archived)
    let archivedCount = 0;
    Object.keys(monthsWithIncome).forEach(monthKey => {
        if (monthKey !== currentMonthKey && !projectionHistory[monthKey]) {
            // This is a completed month that hasn't been archived
            const seasonalFactor = seasonalFactors[monthKey] || 1.0;
            
            // Calculate 12-month rolling average up to this month
            const priorMonths = Object.keys(monthsWithIncome)
                .filter(m => m < monthKey && m !== currentMonthKey)
                .sort()
                .slice(-12);
            
            const rollingAvg = priorMonths.length > 0
                ? priorMonths.reduce((sum, m) => sum + monthsWithIncome[m], 0) / priorMonths.length
                : 0;
            
            const baseline = rollingAvg * seasonalFactor;
            const conservative = baseline * 0.75;
            const optimistic = baseline * 1.25;
            const actual = monthsWithIncome[monthKey];
            
            // Auto-archive this month
            projectionHistory[monthKey] = {
                seasonalFactor: seasonalFactor,
                baseline: baseline > 0 ? baseline : actual, // Use actual if no baseline available
                conservative: conservative > 0 ? conservative : actual * 0.75,
                optimistic: optimistic > 0 ? optimistic : actual * 1.25,
                actual: actual,
                accuracyType: 'vs Conservative',
                accuracyPercentage: conservative > 0 ? Math.abs((actual - conservative) / conservative * 100) : 0,
                vsConservativeStatus: actual >= conservative ? 'Met ✅' : 'Missed ❌',
                autoArchived: true,
                created: new Date().toISOString()
            };
            
            archivedCount++;
            console.log(`Auto-archived ${monthKey} with actual income: ${formatCurrency(actual)}`);
        }
    });
    
    if (archivedCount > 0) {
        saveUserData();
    }
    
    return archivedCount;
}

// Manual archive function for current month
function manuallyArchiveCurrentMonth() {
    const currentMonthKey = getCurrentMonthKey();
    
    if (projectionHistory[currentMonthKey]) {
        if (!confirm(`${currentMonthKey} is already archived. Do you want to update it with current data?`)) {
            return;
        }
    }
    
    const metrics = calculateIncomeMetrics();
    
    if (metrics.currentMonthIncome === 0) {
        alert('No income data for current month to archive.');
        return;
    }
    
    projectionHistory[currentMonthKey] = {
        seasonalFactor: getCurrentSeasonalFactor(),
        baseline: metrics.baselineProjection,
        conservative: metrics.conservativeProjection,
        optimistic: metrics.optimisticProjection,
        actual: metrics.currentMonthIncome,
        accuracyType: 'vs Conservative',
        accuracyPercentage: Math.abs(metrics.variancePercentage),
        vsConservativeStatus: metrics.currentMonthIncome >= metrics.conservativeProjection ? 'Met ✅' : 'Missed ❌',
        manualArchive: true,
        created: new Date().toISOString()
    };
    
    updateProjectionHistoryTable();
    saveUserData();
    
    alert(`Current month (${currentMonthKey}) archived successfully with ${formatCurrency(metrics.currentMonthIncome)} actual income.`);
}

// Sort transactions
function sortTransactions(column) {
    // Toggle direction if clicking same column
    if (transactionSort.column === column) {
        transactionSort.direction = transactionSort.direction === 'asc' ? 'desc' : 'asc';
    } else {
        transactionSort.column = column;
        transactionSort.direction = column === 'date' ? 'desc' : 'asc'; // Default newest first for date
    }
    
    updateTransactionsTable();
}

        // Wait for Firebase to be ready
        window.addEventListener('firebaseReady', function() {
            firebaseReady = true;
            initializeAuth();
        });

        // Authentication Functions
        function initializeAuth() {
            window.firebaseServices.onAuthStateChanged(window.firebaseServices.auth, (user) => {
                if (user) {
                    currentUser = user;
                    showSignedInState(user);
                    loadUserData();
                } else {
                    currentUser = null;
                    showSignedOutState();
                    // Initialize with local data when not signed in
                    initializeLocalData();
                }
            });
        }

        function initializeLocalData() {
            updateDashboard();
            updateTransactionsTable();
            updateCategoriesView();
            updateRulesView();
            updateSubscriptionsView();
            updateIncomeVarianceAnalysis();
            updateProjectionHistoryTable();
        }

        function showSignedInState(user) {
            document.getElementById('signedOutContainer').style.display = 'none';
            document.getElementById('signedInContainer').style.display = 'block';
            document.getElementById('userDisplayName').textContent = user.displayName || 'User';
            document.getElementById('userEmail').textContent = user.email;
            document.getElementById('userPhoto').src = user.photoURL || '';
            document.getElementById('syncStatus').textContent = 'Connected - Data syncing to cloud';
        }

        function showSignedOutState() {
            document.getElementById('signedOutContainer').style.display = 'block';
            document.getElementById('signedInContainer').style.display = 'none';
            document.getElementById('syncStatus').textContent = 'Sign in to sync data to the cloud';
        }

        async function signInWithGoogle() {
            if (!firebaseReady) {
                alert('Firebase is not ready yet. Please wait a moment and try again.');
                return;
            }

            try {
                const result = await window.firebaseServices.signInWithPopup(window.firebaseServices.auth, window.firebaseServices.provider);
                console.log('Sign in successful:', result.user.email);
            } catch (error) {
                console.error('Sign in error:', error);
                if (error.code === 'auth/popup-blocked') {
                    alert('Popup was blocked. Please allow popups for this site and try again.');
                } else if (error.code === 'auth/popup-closed-by-user') {
                    alert('Sign in was cancelled.');
                } else {
                    alert('Failed to sign in: ' + error.message);
                }
            }
        }

        async function signOutUser() {
            try {
                await window.firebaseServices.signOut(window.firebaseServices.auth);
                console.log('User signed out');
            } catch (error) {
                console.error('Error signing out:', error);
            }
        }

        // Data Management
        async function loadUserData() {
            if (!currentUser || !firebaseReady) return;
            
            try {
                const userDocRef = window.firebaseServices.doc(window.firebaseServices.db, 'users', currentUser.uid);
                const userDoc = await window.firebaseServices.getDoc(userDocRef);
                
                if (userDoc.exists()) {
                    const data = userDoc.data();
                    transactions = data.transactions || [];
                    categories = data.categories || categories;
                    rules = data.rules || [];
                    subscriptions = data.subscriptions || [];
                    seasonalFactors = data.seasonalFactors || {};
                    projectionHistory = data.projectionHistory || {};
                } else {
                    await saveUserData();
                }
                
                updateDashboard();
                updateTransactionsTable();
                updateCategoriesView();
                updateRulesView();
                updateSubscriptionsView();
                updateIncomeVarianceAnalysis();
                updateProjectionHistoryTable();
                
            } catch (error) {
                console.error('Error loading user data:', error);
            }
        }

        async function saveUserData() {
            if (!currentUser || !firebaseReady) return;
            
            try {
                const data = {
                    transactions,
                    categories,
                    rules,
                    subscriptions,
                    seasonalFactors,
                    projectionHistory,
                    lastSaved: new Date().toISOString(),
                    userId: currentUser.uid
                };
                
                const userDocRef = window.firebaseServices.doc(window.firebaseServices.db, 'users', currentUser.uid);
                await window.firebaseServices.setDoc(userDocRef, data);
                
            } catch (error) {
                console.error('Error saving user data:', error);
            }
        }

        // Enhanced subscription matching functions
        function normalizeSubscriptionName(description) {
            // Remove common variable elements and normalize
            return description
                .toLowerCase()
                .replace(/\b\d{4,}\b/g, '') // Remove long numbers (account numbers, etc.)
                .replace(/\b[a-z0-9]{8,}\b/gi, '') // Remove long alphanumeric codes
                .replace(/[*#\-_]/g, ' ') // Remove special characters
                .replace(/\s+/g, ' ') // Normalize whitespace
                .trim();
        }

        function extractVendorKeywords(description) {
            // Extract first 1-2 significant words as vendor keywords
            const normalized = normalizeSubscriptionName(description);
            const words = normalized.split(' ').filter(word => word.length > 2);
            return words.slice(0, 2).join(' ');
        }

        function findSimilarSubscription(description, amount) {
            const normalized = normalizeSubscriptionName(description);
            const keywords = extractVendorKeywords(description);
            const descLower = description.toLowerCase();

            return subscriptions.find(sub => {
                // Check pattern matching first (highest priority)
                if (sub.pattern && sub.pattern.type && sub.pattern.value) {
                    const patternValue = sub.pattern.value.toLowerCase();
                    let patternMatch = false;

                    switch (sub.pattern.type) {
                        case 'contains':
                            patternMatch = descLower.includes(patternValue);
                            break;
                        case 'starts_with':
                            patternMatch = descLower.startsWith(patternValue);
                            break;
                        case 'ends_with':
                            patternMatch = descLower.endsWith(patternValue);
                            break;
                        case 'equals':
                            patternMatch = descLower === patternValue;
                            break;
                    }

                    if (patternMatch) {
                        return true;
                    }
                }

                // Check aliases
                if (sub.aliases && sub.aliases.some(alias =>
                    normalized.includes(alias.toLowerCase()) ||
                    alias.toLowerCase().includes(keywords)
                )) {
                    return true;
                }

                // Check vendor name similarity
                const subNormalized = normalizeSubscriptionName(sub.vendor);
                const subKeywords = extractVendorKeywords(sub.vendor);

                const keywordMatch = keywords.includes(subKeywords) ||
                                   subKeywords.includes(keywords) ||
                                   normalized.includes(subNormalized) ||
                                   subNormalized.includes(normalized);

                // Amount should be within 50% (allows for price changes)
                const amountSimilar = Math.abs(sub.amount - amount) / Math.max(sub.amount, amount) < 0.5;

                return keywordMatch && amountSimilar;
            });
        }

        function detectSubscription(transaction, detectedSubscriptions) {
    const desc = transaction.description.toLowerCase();
    const amount = Math.abs(transaction.amount);
    const transactionDate = transaction.date;
    
    // Common subscription keywords
    const subscriptionKeywords = [
        'netflix', 'spotify', 'amazon prime', 'hulu', 'disney', 'apple music',
        'adobe', 'microsoft', 'google', 'dropbox', 'office 365',
        'gym', 'fitness', 'insurance', 'phone', 'internet', 'cable',
        'subscription', 'monthly', 'annual', 'recurring'
    ];

    const isLikelySubscription = subscriptionKeywords.some(keyword => desc.includes(keyword)) ||
                              desc.includes('auto pay') || 
                              desc.includes('recurring') ||
                              desc.includes('monthly');

    if (isLikelySubscription) {
        const existingSubscription = findSimilarSubscription(transaction.description, amount);
        
        if (existingSubscription) {
            // Update existing subscription with actual charge date
            if (Math.abs(existingSubscription.amount - amount) > 0.01) {
                existingSubscription.priceChanged = true;
                existingSubscription.newAmount = amount;
            }
            existingSubscription.lastCharge = transactionDate;
            existingSubscription.nextCharge = calculateNextChargeFromDate(transactionDate, existingSubscription.frequency);
            
            // Add the transaction description as a potential new alias if it's different
            const normalized = normalizeSubscriptionName(transaction.description);
            const existingNormalized = normalizeSubscriptionName(existingSubscription.vendor);
            if (normalized !== existingNormalized) {
                if (!existingSubscription.suggestedAliases) {
                    existingSubscription.suggestedAliases = [];
                }
                if (!existingSubscription.suggestedAliases.includes(transaction.description)) {
                    existingSubscription.suggestedAliases.push(transaction.description);
                }
            }
            return;
        }
        
        const existingDetection = detectedSubscriptions.find(sub => {
            const subNormalized = normalizeSubscriptionName(sub.vendor);
            const transNormalized = normalizeSubscriptionName(transaction.description);
            return subNormalized === transNormalized;
        });

        if (existingDetection) {
            existingDetection.transactions.push(transaction);
            // Use the most recent date
            if (transaction.date > existingDetection.lastDate) {
                existingDetection.lastDate = transaction.date;
            }
            if (Math.abs(existingDetection.amount - amount) > 0.01) {
                existingDetection.priceChanged = true;
                existingDetection.newAmount = amount;
            }
        } else {
            detectedSubscriptions.push({
                vendor: transaction.description,
                amount: amount,
                category: transaction.category,
                lastDate: transactionDate,
                transactions: [transaction],
                priceChanged: false
            });
        }
    }
}

        // Seasonal Factor Management
        function getCurrentMonthKey() {
            const now = new Date();
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        }

        function getCurrentSeasonalFactor() {
            const monthKey = getCurrentMonthKey();
            return seasonalFactors[monthKey] || 1.0;
        }

        function setSeasonalFactor(factor) {
            document.getElementById('currentSeasonalFactor').value = factor;
            updateCurrentSeasonalFactor();
        }

        function updateCurrentSeasonalFactor() {
            const factorInput = document.getElementById('currentSeasonalFactor');
            const factor = parseFloat(factorInput.value) || 1.0;
            
            if (factor < 0.1 || factor > 3.0) {
                alert('Seasonal factor must be between 0.1 and 3.0');
                return;
            }
            
            const monthKey = getCurrentMonthKey();
            seasonalFactors[monthKey] = factor;
            
            updateSeasonalFactorDisplay();
            updateIncomeVarianceAnalysis();
            saveUserData();
            
            alert(`Seasonal factor for ${monthKey} updated to ${factor}`);
        }

        function updateSeasonalFactorDisplay() {
            const currentFactor = getCurrentSeasonalFactor();
            document.getElementById('currentSeasonalFactorDisplay').textContent = currentFactor.toFixed(1);
            document.getElementById('currentSeasonalFactor').value = currentFactor;
        }

        // Income Variance Analysis with 12-month focus and Conservative target
        function calculateIncomeMetrics() {
    const now = new Date();
    const currentMonthKey = getCurrentMonthKey();
    
    // Check and archive any completed months first
    checkAndArchiveCompletedMonths();
    
    // Get income transactions only
    const incomeTransactions = transactions.filter(t => t.amount > 0 && !t.excludeFromTotals);
            
            if (incomeTransactions.length === 0) {
                return {
                    rollingAverage: 0,
                    currentMonthIncome: 0,
                    baselineProjection: 0,
                    conservativeProjection: 0,
                    optimisticProjection: 0,
                    variancePercentage: 0,
                    availableMonths: 0
                };
            }
            
            // Group income by month
            const monthlyIncome = {};
            incomeTransactions.forEach(t => {
                const date = new Date(t.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                monthlyIncome[monthKey] = (monthlyIncome[monthKey] || 0) + t.amount;
            });
            
            // Calculate 12-month rolling average (excluding current incomplete month)
            const sortedMonths = Object.keys(monthlyIncome)
                .filter(month => month !== currentMonthKey) // Exclude current month
                .sort()
                .slice(-12); // Last 12 complete months (or whatever we have)
            
            const availableMonths = sortedMonths.length;
            const rollingAverage = sortedMonths.length > 0 
                ? sortedMonths.reduce((sum, month) => sum + monthlyIncome[month], 0) / sortedMonths.length
                : 0;
            
            // Current month income
            const currentMonthIncome = monthlyIncome[currentMonthKey] || 0;
            
            // Get seasonal factor
            const seasonalFactor = getCurrentSeasonalFactor();
            
            // Calculate projections
            const baselineProjection = rollingAverage * seasonalFactor;
            const conservativeProjection = baselineProjection * 0.75;
            const optimisticProjection = baselineProjection * 1.25;
            
            // Calculate variance percentage against Conservative target (our new goal)
            const variancePercentage = conservativeProjection > 0 
                ? ((currentMonthIncome - conservativeProjection) / conservativeProjection * 100)
                : 0;
            
            return {
                rollingAverage,
                currentMonthIncome,
                baselineProjection,
                conservativeProjection,
                optimisticProjection,
                variancePercentage,
                monthlyIncome,
                sortedMonths,
                availableMonths
            };
        }

        function updateIncomeVarianceAnalysis() {
            const metrics = calculateIncomeMetrics();
            
            // Update displays
            document.getElementById('rollingAverage').textContent = formatCurrency(metrics.rollingAverage);
            document.getElementById('availableMonthsCount').textContent = metrics.availableMonths;
            document.getElementById('currentMonthIncome').textContent = formatCurrency(metrics.currentMonthIncome);
            document.getElementById('baselineProjection').textContent = formatCurrency(metrics.baselineProjection);
            document.getElementById('conservativeProjection').textContent = formatCurrency(metrics.conservativeProjection);
            document.getElementById('optimisticProjection').textContent = formatCurrency(metrics.optimisticProjection);
            
            // Update variance percentage with color coding (vs Conservative target)
            const varianceElement = document.getElementById('variancePercentage');
            const isPositive = metrics.variancePercentage >= 0;
            varianceElement.textContent = `${isPositive ? '+' : ''}${metrics.variancePercentage.toFixed(1)}%`;
            varianceElement.style.color = isPositive ? '#059669' : '#dc2626';
            
            // Update variance card styling
            const varianceCard = document.getElementById('varianceCard');
            varianceCard.className = `variance-card ${isPositive ? 'variance-positive' : 'variance-negative'}`;
            
            // Update monthly progress bar (vs Conservative target)
            updateMonthlyProgressBar(metrics);
            
            // Update seasonal factor display
            updateSeasonalFactorDisplay();
            
            // Update seasonal factor history
            updateSeasonalFactorHistory();

            // Update the cash flow charts
            updateIncomeVsExpensesChart(metrics.monthlyIncome);
            updateRunningBalanceChart(transactions.filter(t => !t.excludeFromTotals));
        }

        function updateMonthlyProgressBar(metrics) {
            const container = document.getElementById('monthlyProgressBar');
            if (!container) return;
            
            const now = new Date();
            const daysInMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
            const dayOfMonth = now.getDate();
            const monthProgress = (dayOfMonth / daysInMonth) * 100;
            
            // Calculate expected progress vs Conservative target (not baseline)
            const expectedAtThisPoint = metrics.conservativeProjection * (dayOfMonth / daysInMonth);
            const actualProgress = metrics.currentMonthIncome;
            const progressVsExpected = expectedAtThisPoint > 0 ? (actualProgress / expectedAtThisPoint) * 100 : 0;
            
            container.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span>Month Progress (Day ${dayOfMonth} of ${daysInMonth})</span>
                        <span>${monthProgress.toFixed(1)}%</span>
                    </div>
                    <div style="width: 100%; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
                        <div style="width: ${monthProgress}%; height: 100%; background: #667eea; transition: width 0.3s ease;"></div>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span>Income vs Conservative Target (${formatCurrency(actualProgress)} / ${formatCurrency(expectedAtThisPoint)})</span>
                        <span style="color: ${progressVsExpected >= 100 ? '#059669' : '#dc2626'};">${progressVsExpected.toFixed(1)}%</span>
                    </div>
                    <div style="width: 100%; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
                        <div style="width: ${Math.min(progressVsExpected, 100)}%; height: 100%; background: ${progressVsExpected >= 100 ? '#059669' : '#dc2626'}; transition: width 0.3s ease;"></div>
                    </div>
                </div>
                
                <div style="background: #f7fafc; padding: 10px; border-radius: 6px; font-size: 0.9em;">
                    ${progressVsExpected >= 120 ? '🎉 Exceeding Conservative target!' :
                      progressVsExpected >= 100 ? '✅ Meeting Conservative target' :
                      progressVsExpected >= 80 ? '⚠️ Below Conservative target' :
                      '🔴 Significantly below Conservative target'}
                </div>
                
                <div style="margin-top: 10px; font-size: 0.8em; color: #718096; text-align: center;">
                    Conservative target is your minimum monthly goal. Baseline is ${formatCurrency(metrics.baselineProjection)}.
                </div>
            `;
        }

        function updateSeasonalFactorHistory() {
            const container = document.getElementById('seasonalFactorHistory');
            if (!container) return;
            
            const sortedFactors = Object.keys(seasonalFactors).sort().slice(-12); // Last 12 months
            
            if (sortedFactors.length === 0) {
                container.innerHTML = '<p>No seasonal factors set yet. Start by setting the current month factor above.</p>';
                return;
            }
            
            container.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;">
                    ${sortedFactors.map(monthKey => {
                        const [year, month] = monthKey.split('-');
                        const monthName = new Date(year, month - 1).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                        const factor = seasonalFactors[monthKey];
                        const isCurrent = monthKey === getCurrentMonthKey();
                        
                        return `
                            <div style="
                                padding: 10px; 
                                border: 2px solid ${isCurrent ? '#667eea' : '#e2e8f0'}; 
                                border-radius: 6px; 
                                text-align: center;
                                background: ${isCurrent ? '#f7fafc' : 'white'};
                            ">
                                <div style="font-weight: bold; margin-bottom: 5px;">${monthName}</div>
                                <div style="font-size: 1.2em; color: ${factor > 1.1 ? '#059669' : factor < 0.9 ? '#dc2626' : '#4a5568'};">
                                    ${factor.toFixed(1)}
                                </div>
                                ${isCurrent ? '<div style="font-size: 0.7em; color: #667eea;">CURRENT</div>' : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // UI Functions
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');

            // Update category filter when showing transactions tab
            if (tabName === 'transactions') {
                populateCategoryFilter();
            }

            // Update income analysis when cash flow tab is shown
            if (tabName === 'cashflow') {
                updateIncomeVarianceAnalysis();
                updateProjectionHistoryTable();
            }
        }

        function showUncategorizedTransactions() {
            // Switch to transactions tab
            showTab('transactions');

            // Set the category filter to uncategorized
            const categoryFilter = document.getElementById('categoryFilter');
            if (categoryFilter) {
                categoryFilter.value = 'uncategorized';
                updateTransactionsTable();
            }

            // Highlight the active tab
            document.querySelectorAll('.nav-tab').forEach((tab, index) => {
                if (tab.textContent.trim() === 'Transactions') {
                    tab.classList.add('active');
                }
            });
        }

        function populateCategoryFilter() {
            const categoryFilter = document.getElementById('categoryFilter');
            if (!categoryFilter) return;

            const currentValue = categoryFilter.value;

            // Sort categories alphabetically
            const sortedIncome = [...categories.income].sort((a, b) => a.localeCompare(b));
            const sortedExpense = [...categories.expense].sort((a, b) => a.localeCompare(b));

            // Build the options HTML
            let optionsHTML = `
                <option value="">All Categories</option>
                <option value="uncategorized">Uncategorized Only</option>
                <optgroup label="Income Categories">
                    ${sortedIncome.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </optgroup>
                <optgroup label="Expense Categories">
                    ${sortedExpense.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </optgroup>
            `;

            categoryFilter.innerHTML = optionsHTML;

            // Restore previous selection if it still exists
            if (currentValue) {
                categoryFilter.value = currentValue;
            }
        }

        function updateDashboard() {
            // Use ALL transactions, not just current month
            const activeTransactions = transactions.filter(t => !t.excludeFromTotals);

            const totalIncome = activeTransactions
                .filter(t => t.amount > 0)
                .reduce((sum, t) => sum + t.amount, 0);

            const totalExpenses = activeTransactions
                .filter(t => t.amount < 0)
                .reduce((sum, t) => sum + Math.abs(t.amount), 0);

            const uncategorizedCount = transactions.filter(t => 
                (t.category === 'Uncategorized' || !t.category) && !t.excludeFromTotals
            ).length;

            const duplicateCount = transactions.filter(t => t.isDuplicateFlag).length;

            document.getElementById('totalIncome').textContent = formatCurrency(totalIncome);
            document.getElementById('totalExpenses').textContent = formatCurrency(totalExpenses);
            document.getElementById('netCashFlow').textContent = formatCurrency(totalIncome - totalExpenses);
            document.getElementById('uncategorizedCount').textContent = uncategorizedCount;

            // Add duplicate alert if there are flagged duplicates
            updateDuplicateAlert(duplicateCount);
            updateRecentTransactions();
            updateCategoryBreakdown();
            updateIncomeVarianceAnalysis();
        }

        function updateCategoryBreakdown() {
            const container = document.getElementById('categoryBreakdown');
            const activeTransactions = transactions.filter(t => !t.excludeFromTotals);
            
            if (activeTransactions.length === 0) {
                container.innerHTML = '<p>Categories will appear here once you add transactions.</p>';
                return;
            }

            // Separate income and expense transactions
            const incomeTransactions = activeTransactions.filter(t => t.amount > 0);
            const expenseTransactions = activeTransactions.filter(t => t.amount < 0);

            // Group by category for expenses (most useful breakdown)
            const expenseTotals = {};
            expenseTransactions.forEach(t => {
                const category = t.category || 'Uncategorized';
                if (!expenseTotals[category]) {
                    expenseTotals[category] = 0;
                }
                expenseTotals[category] += Math.abs(t.amount);
            });

            // Group by category for income
            const incomeTotals = {};
            incomeTransactions.forEach(t => {
                const category = t.category || 'Uncategorized';
                if (!incomeTotals[category]) {
                    incomeTotals[category] = 0;
                }
                incomeTotals[category] += t.amount;
            });

            // Sort categories by total amount (descending)
            const sortedExpenses = Object.entries(expenseTotals)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 8); // Show top 8 expense categories

            const sortedIncome = Object.entries(incomeTotals)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5); // Show top 5 income categories

            const totalExpenses = Object.values(expenseTotals).reduce((sum, amount) => sum + amount, 0);
            const totalIncome = Object.values(incomeTotals).reduce((sum, amount) => sum + amount, 0);

            container.innerHTML = `
                <div style="max-height: 400px; overflow-y: auto;">
                    ${sortedExpenses.length > 0 ? `
                        <div style="margin-bottom: 20px;">
                            <h5 style="color: #e53e3e; margin-bottom: 10px;">💸 Top Expenses</h5>
                            ${sortedExpenses.map(([category, amount]) => {
                                const percentage = totalExpenses > 0 ? (amount / totalExpenses * 100).toFixed(1) : 0;
                                return `
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #e2e8f0;">
                                        <div style="flex: 1;">
                                            <strong>${category}</strong>
                                            <div style="width: 80px; height: 4px; background: #fee; border-radius: 2px; margin-top: 2px;">
                                                <div style="width: ${percentage}%; height: 100%; background: #e53e3e; border-radius: 2px;"></div>
                                            </div>
                                        </div>
                                        <div style="text-align: right; margin-left: 10px;">
                                            <div style="font-weight: bold; color: #e53e3e;">${formatCurrency(amount)}</div>
                                            <div style="font-size: 0.75em; color: #718096;">${percentage}%</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #e53e3e; font-weight: bold; color: #e53e3e;">
                                Total Expenses: ${formatCurrency(totalExpenses)}
                            </div>
                        </div>
                    ` : ''}
                    
                    ${sortedIncome.length > 0 ? `
                        <div>
                            <h5 style="color: #059669; margin-bottom: 10px;">💰 Income Sources</h5>
                            ${sortedIncome.map(([category, amount]) => {
                                const percentage = totalIncome > 0 ? (amount / totalIncome * 100).toFixed(1) : 0;
                                return `
                                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #e2e8f0;">
                                        <div style="flex: 1;">
                                            <strong>${category}</strong>
                                            <div style="width: 80px; height: 4px; background: #f0fff4; border-radius: 2px; margin-top: 2px;">
                                                <div style="width: ${percentage}%; height: 100%; background: #059669; border-radius: 2px;"></div>
                                            </div>
                                        </div>
                                        <div style="text-align: right; margin-left: 10px;">
                                            <div style="font-weight: bold; color: #059669;">${formatCurrency(amount)}</div>
                                            <div style="font-size: 0.75em; color: #718096;">${percentage}%</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #059669; font-weight: bold; color: #059669;">
                                Total Income: ${formatCurrency(totalIncome)}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function updateDuplicateAlert(duplicateCount) {
            // Remove existing alert
            const existingAlert = document.getElementById('duplicateAlert');
            if (existingAlert) {
                existingAlert.remove();
            }

            if (duplicateCount > 0) {
                const dashboardGrid = document.querySelector('.dashboard-grid');
                const alertHtml = `
                    <div id="duplicateAlert" class="stat-card" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">
                        <div class="stat-value">${duplicateCount}</div>
                        <div class="stat-label">Flagged Duplicates</div>
                        <button class="btn btn-secondary" onclick="showDuplicateManager()" style="margin-top: 10px; padding: 5px 10px; font-size: 0.8em;">
                            Review Duplicates
                        </button>
                    </div>
                `;
                dashboardGrid.insertAdjacentHTML('beforeend', alertHtml);
            }
        }

        function resolveDuplicate(transactionId) {
            const transaction = transactions.find(t => t.id === transactionId);
            if (!transaction) return;

            // Show inline resolution options instead of popup
            showDuplicateResolutionPanel(transactionId);
        }

        function showDuplicateResolutionPanel(transactionId) {
            const transaction = transactions.find(t => t.id === transactionId);
            if (!transaction) return;

            const groupId = transaction.duplicateGroup;
            const groupMembers = transactions.filter(t => t.duplicateGroup === groupId);

            // Create or show the duplicate panel
            let panel = document.getElementById('duplicateResolutionPanel');
            if (!panel) {
                panel = document.createElement('div');
                panel.id = 'duplicateResolutionPanel';
                panel.className = 'duplicate-panel';
                
                // Insert at the top of the transactions card
                const transactionsCard = document.querySelector('#transactions .card');
                transactionsCard.insertBefore(panel, transactionsCard.firstChild);
            }

            panel.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h4 style="margin: 0; color: #92400e;">⚠️ Resolve Duplicate Transactions</h4>
                    <button class="btn btn-secondary" onclick="closeDuplicatePanel()" style="padding: 5px 10px;">Close</button>
                </div>
                
                <p style="margin-bottom: 15px;">These transactions appear to be duplicates. Choose how to handle them:</p>
                
                <div class="duplicate-group">
                    <div style="font-weight: bold; margin-bottom: 10px; color: #92400e;">
                        Group: ${groupMembers[0].description}
                    </div>
                    ${groupMembers.map(t => `
                        <div class="duplicate-item" style="${t.id === transactionId ? 'background: #fef3c7;' : ''}">
                            <div style="flex: 1;">
                                <div style="font-weight: bold;">${formatDate(t.date)}</div>
                                <div style="font-size: 0.9em; color: #718096;">${t.description}</div>
                                <div style="font-weight: bold; color: ${t.amount > 0 ? '#059669' : '#dc2626'}; margin-top: 5px;">
                                    ${formatCurrency(t.amount)}
                                </div>
                            </div>
                            <div style="display: flex; gap: 5px;">
                                <button class="btn" onclick="keepThisTransaction('${t.id}')" style="padding: 5px 10px; background: #059669;">
                                    Keep This
                                </button>
                                <button class="btn btn-danger" onclick="deleteThisTransaction('${t.id}')" style="padding: 5px 10px;">
                                    Delete This
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button class="btn" onclick="keepAllInGroup('${groupId}')" style="background: #059669;">
                        Keep All (Legitimate Multiple Charges)
                    </button>
                    <button class="btn btn-danger" onclick="deleteAllInGroup('${groupId}')">
                        Delete All
                    </button>
                </div>
            `;

            panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function closeDuplicatePanel() {
            const panel = document.getElementById('duplicateResolutionPanel');
            if (panel) {
                panel.remove();
            }
        }

        function keepThisTransaction(transactionId) {
            const transaction = transactions.find(t => t.id === transactionId);
            if (!transaction) return;

            const groupId = transaction.duplicateGroup;
            const groupMembers = transactions.filter(t => t.duplicateGroup === groupId && t.id !== transactionId);

            // Mark this one as legitimate
            transaction.isDuplicateFlag = false;
            transaction.excludeFromTotals = false;
            delete transaction.duplicateGroup;

            // If only one other remains, also mark it as legitimate
            if (groupMembers.length === 1) {
                groupMembers[0].isDuplicateFlag = false;
                groupMembers[0].excludeFromTotals = false;
                delete groupMembers[0].duplicateGroup;
                closeDuplicatePanel();
            } else if (groupMembers.length === 0) {
                closeDuplicatePanel();
            } else {
                // Refresh the panel with remaining duplicates
                showDuplicateResolutionPanel(groupMembers[0].id);
            }

            updateDashboard();
            updateTransactionsTable();
            saveUserData();
        }

        function deleteThisTransaction(transactionId) {
            const transaction = transactions.find(t => t.id === transactionId);
            if (!transaction) return;

            const groupId = transaction.duplicateGroup;
            const groupMembers = transactions.filter(t => t.duplicateGroup === groupId && t.id !== transactionId);

            // Delete this transaction
            transactions = transactions.filter(t => t.id !== transactionId);

            // If only one remains, mark it as legitimate
            if (groupMembers.length === 1) {
                groupMembers[0].isDuplicateFlag = false;
                groupMembers[0].excludeFromTotals = false;
                delete groupMembers[0].duplicateGroup;
                closeDuplicatePanel();
            } else if (groupMembers.length === 0) {
                closeDuplicatePanel();
            } else {
                // Refresh the panel with remaining duplicates
                showDuplicateResolutionPanel(groupMembers[0].id);
            }

            updateDashboard();
            updateTransactionsTable();
            saveUserData();
        }

        function keepAllInGroup(groupId) {
            transactions.forEach(t => {
                if (t.duplicateGroup === groupId) {
                    t.isDuplicateFlag = false;
                    t.excludeFromTotals = false;
                    delete t.duplicateGroup;
                }
            });

            closeDuplicatePanel();
            updateDashboard();
            updateTransactionsTable();
            saveUserData();
        }

        function deleteAllInGroup(groupId) {
            if (confirm('Delete all transactions in this duplicate group? This cannot be undone.')) {
                transactions = transactions.filter(t => t.duplicateGroup !== groupId);
                
                closeDuplicatePanel();
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
            }
        }
        function showDuplicateManager() {
            const duplicateGroups = {};
            
            // Group duplicates
            transactions.forEach(t => {
                if (t.isDuplicateFlag && t.duplicateGroup) {
                    if (!duplicateGroups[t.duplicateGroup]) {
                        duplicateGroups[t.duplicateGroup] = [];
                    }
                    duplicateGroups[t.duplicateGroup].push(t);
                }
            });

            let message = "DUPLICATE MANAGER\n\n";
            message += "Flagged transactions excluded from totals:\n\n";

            Object.keys(duplicateGroups).forEach((groupId, index) => {
                const group = duplicateGroups[groupId];
                message += `GROUP ${index + 1}:\n`;
                group.forEach((t, i) => {
                    message += `  ${i + 1}. ${formatDate(t.date)} - ${t.description} - ${formatCurrency(t.amount)}\n`;
                });
                message += "\n";
            });

            message += "Go to Transactions tab to resolve individual duplicates,\n";
            message += "or use bulk operations to manage multiple transactions.";

            alert(message);
        }

        function updateRecentTransactions() {
            const recent = transactions
                .filter(t => !t.excludeFromTotals) // Exclude flagged duplicates
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 5);

            const container = document.getElementById('recentTransactions');
            container.innerHTML = recent.length ? recent.map(t => `
                <div style="padding: 10px; border-bottom: 1px solid #e2e8f0;">
                    <strong>${t.description}</strong><br>
                    <small>${formatDate(t.date)} - ${t.category || 'Uncategorized'}</small>
                    <span style="float: right; color: ${t.amount > 0 ? 'green' : 'red'};">
                        ${formatCurrency(t.amount)}
                    </span>
                </div>
            `).join('') : '<p>No transactions yet. Start by importing data or adding transactions manually.</p>';
        }

        function updateTransactionsTable() {
            const tbody = document.querySelector('#transactionsTable tbody');
            const searchTerm = document.getElementById('transactionSearch')?.value.toLowerCase() || '';
            const categoryFilter = document.getElementById('categoryFilter')?.value || '';
            
            let filteredTransactions = transactions;
            
            // Apply search filter
            if (searchTerm) {
                filteredTransactions = filteredTransactions.filter(t => {
                    // Search in description
                    if (t.description.toLowerCase().includes(searchTerm)) return true;
                    
                    // Search in category
                    if (t.category && t.category.toLowerCase().includes(searchTerm)) return true;
                    
                    // Search by amount (both exact and partial matches)
                    const amountStr = Math.abs(t.amount).toFixed(2);
                    const formattedAmount = formatCurrency(t.amount).toLowerCase();
                    
                    // Check if search term is a number or partial number
                    if (amountStr.includes(searchTerm.replace(/[$,]/g, ''))) return true;
                    
                    // Check formatted amount (with dollar sign and commas)
                    if (formattedAmount.includes(searchTerm)) return true;
                    
                    return false;
                });
            }
            
            // Apply category filter
            if (categoryFilter) {
                if (categoryFilter === 'uncategorized') {
                    filteredTransactions = filteredTransactions.filter(t => 
                        !t.category || t.category === 'Uncategorized'
                    );
                } else {
                    filteredTransactions = filteredTransactions.filter(t => 
                        t.category === categoryFilter
                    );
                }
            }
            
            // Sort by date (newest first)
// Apply sorting
filteredTransactions.sort((a, b) => {
    let aVal, bVal;
    
    switch (transactionSort.column) {
        case 'date':
            aVal = new Date(a.date);
            bVal = new Date(b.date);
            break;
        case 'description':
            aVal = a.description.toLowerCase();
            bVal = b.description.toLowerCase();
            break;
        case 'amount':
            aVal = a.amount;
            bVal = b.amount;
            break;
        case 'category':
            aVal = (a.category || 'Uncategorized').toLowerCase();
            bVal = (b.category || 'Uncategorized').toLowerCase();
            break;
        default:
            aVal = new Date(a.date);
            bVal = new Date(b.date);
    }
    
    if (aVal < bVal) return transactionSort.direction === 'asc' ? -1 : 1;
    if (aVal > bVal) return transactionSort.direction === 'asc' ? 1 : -1;
    return 0;
});

// Update table headers to show sort direction
document.querySelectorAll('.sortable-header').forEach(header => {
    header.classList.remove('sort-asc', 'sort-desc');
    if (header.dataset.column === transactionSort.column) {
        header.classList.add(`sort-${transactionSort.direction}`);
    }
});            
            tbody.innerHTML = filteredTransactions.map(t => `
                <tr style="${t.isDuplicateFlag ? 'background-color: #fef3cd; border-left: 4px solid #f59e0b;' : ''}">
                    <td><input type="checkbox" class="transaction-checkbox" value="${t.id}" onchange="updateBulkActions()"></td>
                    <td>${formatDate(t.date)}</td>
                    <td>
                        ${t.description}
                        ${t.isDuplicateFlag ? '<span style="background: #f59e0b; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.7em; margin-left: 5px;">DUPLICATE?</span>' : ''}
                    </td>
                    <td style="color: ${t.amount > 0 ? 'green' : 'red'};">
                        ${formatCurrency(t.amount)}
                        ${t.excludeFromTotals ? '<br><small style="color: #f59e0b;">Excluded from totals</small>' : ''}
                    </td>
                    <td>${t.category || 'Uncategorized'}</td>
                    <td>
                        <button class="btn btn-secondary" onclick="editTransaction('${t.id}')" style="padding: 5px 10px; margin: 2px;">Edit</button>
                        ${t.isDuplicateFlag ? 
                            `<button class="btn" onclick="resolveDuplicate('${t.id}')" style="padding: 5px 10px; margin: 2px; background: #059669;">Resolve</button>` :
                            ''
                        }
                        <button class="btn btn-danger" onclick="deleteTransaction('${t.id}')" style="padding: 5px 10px; margin: 2px;">Delete</button>
                    </td>
                </tr>
            `).join('');
            
            // Update category filter options
            updateCategoryFilterOptions();
            updateBulkCategoryOptions();
            
            // Reset bulk selection
            clearSelection();
        }

        function updateBulkCategoryOptions() {
            const bulkCategorySelect = document.getElementById('bulkCategorySelect');
            if (!bulkCategorySelect) return;
            
            const allCategories = [...categories.income, ...categories.expense];
            
            bulkCategorySelect.innerHTML = `
                <option value="">Choose category...</option>
                <optgroup label="Income Categories">
                    ${categories.income.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </optgroup>
                <optgroup label="Expense Categories">
                    ${categories.expense.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </optgroup>
            `;
        }

        function toggleSelectAll() {
            const selectAll = document.getElementById('selectAllTransactions');
            const checkboxes = document.querySelectorAll('.transaction-checkbox');
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = selectAll.checked;
            });
            
            updateBulkActions();
        }

        function updateBulkActions() {
            const checkboxes = document.querySelectorAll('.transaction-checkbox:checked');
            const bulkActions = document.getElementById('bulkActions');
            const selectedCount = document.getElementById('selectedCount');
            const selectAll = document.getElementById('selectAllTransactions');
            
            const count = checkboxes.length;
            selectedCount.textContent = `${count} transaction${count !== 1 ? 's' : ''} selected`;
            
            if (count > 0) {
                bulkActions.classList.remove('hidden');
            } else {
                bulkActions.classList.add('hidden');
            }
            
            // Update select all checkbox state
            const allCheckboxes = document.querySelectorAll('.transaction-checkbox');
            if (count === 0) {
                selectAll.indeterminate = false;
                selectAll.checked = false;
            } else if (count === allCheckboxes.length) {
                selectAll.indeterminate = false;
                selectAll.checked = true;
            } else {
                selectAll.indeterminate = true;
            }
        }

        function clearSelection() {
            document.querySelectorAll('.transaction-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            document.getElementById('selectAllTransactions').checked = false;
            document.getElementById('selectAllTransactions').indeterminate = false;
            updateBulkActions();
        }

        function bulkSetCategory() {
            const selectedCategory = document.getElementById('bulkCategorySelect').value;
            if (!selectedCategory) {
                alert('Please select a category');
                return;
            }
            
            const checkboxes = document.querySelectorAll('.transaction-checkbox:checked');
            const selectedIds = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                alert('No transactions selected');
                return;
            }
            
            if (confirm(`Set category to "${selectedCategory}" for ${selectedIds.length} transaction${selectedIds.length !== 1 ? 's' : ''}?`)) {
                selectedIds.forEach(id => {
                    const transaction = transactions.find(t => t.id === id);
                    if (transaction) {
                        transaction.category = selectedCategory;
                    }
                });
                
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
                
                alert(`Updated ${selectedIds.length} transactions`);
            }
        }

        function bulkDeleteTransactions() {
            const checkboxes = document.querySelectorAll('.transaction-checkbox:checked');
            const selectedIds = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedIds.length === 0) {
                alert('No transactions selected');
                return;
            }
            
            if (confirm(`Delete ${selectedIds.length} transaction${selectedIds.length !== 1 ? 's' : ''}? This cannot be undone.`)) {
                transactions = transactions.filter(t => !selectedIds.includes(t.id));
                
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
                
                alert(`Deleted ${selectedIds.length} transactions`);
            }
        }

        function updateCategoryFilterOptions() {
            const categoryFilter = document.getElementById('categoryFilter');
            if (!categoryFilter) return;
            
            const allCategories = [...new Set(transactions.map(t => t.category).filter(c => c))];
            const currentValue = categoryFilter.value;
            
            const filteredCategories = allCategories.filter(cat => cat !== 'Uncategorized');
categoryFilter.innerHTML = `
    <option value="">All Categories</option>
    <option value="Uncategorized">Uncategorized Only</option>
    ${filteredCategories.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
`;
            
            categoryFilter.value = currentValue;
        }

        // Add event listeners for search and filter
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('transactionSearch');
            const categoryFilter = document.getElementById('categoryFilter');
            
            if (searchInput) {
                searchInput.addEventListener('input', updateTransactionsTable);
            }
            
            if (categoryFilter) {
                categoryFilter.addEventListener('change', updateTransactionsTable);
            }

            // Add Enter key support for forms
            document.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    // Check if we're in a category form
                    if (e.target.id === 'newIncomeCategory') {
                        saveNewCategory('income');
                    } else if (e.target.id === 'newExpenseCategory') {
                        saveNewCategory('expense');
                    } else if (e.target.closest('#addRuleForm')) {
                        // If in rule form, save the rule
                        const saveButton = document.querySelector('#addRuleForm .btn[onclick*="Rule"]');
                        if (saveButton) {
                            saveButton.click();
                        }
                    }
                }
            });

            // Set up file input and upload area
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            uploadArea.addEventListener('click', () => fileInput.click());
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#667eea';
                uploadArea.style.background = '#f7fafc';
            });
            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#cbd5e0';
                uploadArea.style.background = 'transparent';
            });
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#cbd5e0';
                uploadArea.style.background = 'transparent';
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFileUpload(files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });
        });

        function updateCategoriesView() {
            const incomeContainer = document.getElementById('incomeCategories');
            const expenseContainer = document.getElementById('expenseCategories');

            // Sort categories alphabetically
            const sortedIncome = [...categories.income].sort((a, b) => a.localeCompare(b));
            const sortedExpense = [...categories.expense].sort((a, b) => a.localeCompare(b));

            incomeContainer.innerHTML = sortedIncome.map((cat, index) => `
                <div style="padding: 10px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
                    <span id="income-cat-${index}">${cat}</span>
                    <div style="display: flex; gap: 5px;">
                        <button class="btn btn-secondary" onclick="editCategory('income', ${index}, '${cat}')" style="padding: 5px 10px;">Edit</button>
                        <button class="btn btn-danger" onclick="deleteCategory('income', '${cat}')" style="padding: 5px 10px;">Delete</button>
                    </div>
                </div>
            `).join('');

            expenseContainer.innerHTML = sortedExpense.map((cat, index) => `
                <div style="padding: 10px; border-bottom: 1px solid #e2e8f0; display: flex; justify-content: space-between; align-items: center;">
                    <span id="expense-cat-${index}">${cat}</span>
                    <div style="display: flex; gap: 5px;">
                        <button class="btn btn-secondary" onclick="editCategory('expense', ${index}, '${cat}')" style="padding: 5px 10px;">Edit</button>
                        <button class="btn btn-danger" onclick="deleteCategory('expense', '${cat}')" style="padding: 5px 10px;">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        // Edit Category Function
        function editCategory(type, index, currentName) {
            const spanId = `${type}-cat-${index}`;
            const span = document.getElementById(spanId);
            
            if (!span) return;
            
            // Create edit form
            const editForm = document.createElement('div');
            editForm.className = 'edit-form';
            editForm.innerHTML = `
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" id="edit-${type}-${index}" class="form-control" value="${currentName}" style="flex: 1;">
                    <button class="btn" onclick="saveCategoryEdit('${type}', ${index}, '${currentName}')" style="padding: 8px 12px;">Save</button>
                    <button class="btn btn-secondary" onclick="cancelCategoryEdit('${type}', ${index})" style="padding: 8px 12px;">Cancel</button>
                </div>
            `;
            
            // Replace the category row with the edit form
            const categoryRow = span.closest('div');
            categoryRow.innerHTML = '';
            categoryRow.appendChild(editForm);
            
            // Focus on the input
            document.getElementById(`edit-${type}-${index}`).focus();
        }

        function saveCategoryEdit(type, index, originalName) {
            const input = document.getElementById(`edit-${type}-${index}`);
            const newName = input.value.trim();
            
            if (!newName) {
                alert('Category name cannot be empty');
                return;
            }
            
            if (newName === originalName) {
                cancelCategoryEdit(type, index);
                return;
            }
            
            // Check if the new name already exists
            if (categories[type].includes(newName)) {
                alert('A category with this name already exists');
                return;
            }
            
            // Update the category
            categories[type][index] = newName;
            
            // Update any transactions that use this category
            transactions.forEach(transaction => {
                if (transaction.category === originalName) {
                    transaction.category = newName;
                }
            });
            
            // Update rules that use this category
            rules.forEach(rule => {
                if (rule.category === originalName) {
                    rule.category = newName;
                }
            });
            
            // Update subscriptions that use this category
            subscriptions.forEach(subscription => {
                if (subscription.category === originalName) {
                    subscription.category = newName;
                }
            });
            
            // Refresh the display
            updateCategoriesView();
            updateTransactionsTable();
            updateRulesView();
            updateSubscriptionsView();
            saveUserData();
            
            alert(`Category renamed from "${originalName}" to "${newName}"`);
        }

        function cancelCategoryEdit(type, index) {
            // Simply refresh the categories view to restore the original display
            updateCategoriesView();
        }

        // Utility Functions
        function formatCurrency(amount) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD'
            }).format(amount);
        }

        function formatDate(date) {
            return new Date(date).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }

        // CSV Import functionality
        let csvData = [];
        let csvHeaders = [];

        function handleFileUpload(file) {
            if (!file.name.toLowerCase().match(/\.(csv|xlsx|xls)$/)) {
                alert('Please upload a CSV or Excel file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                parseCSV(text);
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            // Improved CSV parsing to handle quoted fields, commas in quotes, etc.
            const lines = text.split('\n').filter(line => line.trim());
            if (lines.length < 2) {
                alert('CSV file must have at least a header and one data row.');
                return;
            }

            // Parse CSV with proper quote handling
            function parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const nextChar = line[i + 1];
                    
                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            // Escaped quote
                            current += '"';
                            i++; // Skip next quote
                        } else {
                            // Toggle quote state
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        // End of field
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                // Add the last field
                result.push(current.trim());
                return result;
            }

            csvHeaders = parseCSVLine(lines[0]);
            csvData = [];

            // Parse each data line
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue; // Skip empty lines
                
                const values = parseCSVLine(line);
                
                // Create object from headers and values
                const row = {};
                csvHeaders.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                
                csvData.push(row);
            }

            console.log(`Parsed ${csvData.length} rows from CSV`);
            console.log('Sample row:', csvData[0]);
            
            showColumnMapping();
        }

        function showColumnMapping() {
            const mappingSection = document.getElementById('mappingSection');
            const columnMapping = document.getElementById('columnMapping');
            
            mappingSection.classList.remove('hidden');

           const fieldMappings = [
                { field: 'date', label: 'Date', required: true },
                { field: 'description', label: 'Description', required: true },
                { field: 'amount', label: 'Amount (Debit)', required: false },
                { field: 'creditAmount', label: 'Credit Amount (separate column)', required: false },
                { field: 'transactionType', label: 'Transaction Type (Debit/Credit/Payment)', required: false },
                { field: 'category', label: 'Bank Category', required: false }
            ];

            columnMapping.innerHTML = fieldMappings.map(mapping => `
                <div class="form-group">
                    <label>${mapping.label} ${mapping.required ? '*' : ''}</label>
                    <select id="mapping_${mapping.field}" class="form-control">
                        <option value="">-- Select Column --</option>
                        ${csvHeaders.map(header => `<option value="${header}">${header}</option>`).join('')}
                    </select>
                </div>
            `).join('');

            // Auto-detect common column names
            autoMapColumns();
        }

        function autoMapColumns() {
            const commonMappings = {
                date: ['date', 'transaction date', 'posted date', 'trans date', 'posting date'],
                description: ['description', 'memo', 'payee', 'merchant', 'details', 'transaction description'],
                amount: ['amount', 'transaction amount', 'debit', 'transaction amt', 'debit amount'],
                creditAmount: ['credit', 'credit amount', 'credits', 'payment amount'],
                transactionType: ['transaction type', 'type', 'debit/credit', 'dr/cr', 'transaction kind', 'category'],
                category: ['bank category', 'transaction category', 'classification', 'merchant category']
            };

            Object.keys(commonMappings).forEach(field => {
                const select = document.getElementById(`mapping_${field}`);
                if (select) {
                    const matchingHeader = csvHeaders.find(header => 
                        commonMappings[field].some(pattern => 
                            header.toLowerCase().includes(pattern.toLowerCase())
                        )
                    );
                    if (matchingHeader) {
                        select.value = matchingHeader;
                    }
                }
            });
        }

        function processImport() {
            const mappings = {
                date: document.getElementById('mapping_date').value,
                description: document.getElementById('mapping_description').value,
                amount: document.getElementById('mapping_amount').value,
                creditAmount: document.getElementById('mapping_creditAmount').value,
                transactionType: document.getElementById('mapping_transactionType').value,
                category: document.getElementById('mapping_category').value
            };

            if (!mappings.date || !mappings.description) {
                alert('Please map the required fields: Date and Description');
                return;
            }
            
            if (!mappings.amount && !mappings.creditAmount) {
                alert('Please map at least one amount field (Amount or Credit Amount)');
                return;
            }

            const accountType = document.getElementById('accountType').value;
            let importedCount = 0;
            let skippedCount = 0;
            let detectedSubscriptions = [];
            const importErrors = [];

            console.log(`Processing ${csvData.length} rows...`);

            csvData.forEach((row, index) => {
                const dateStr = row[mappings.date];
                const description = row[mappings.description];
                const amountStr = row[mappings.amount] || '';
                const creditAmountStr = row[mappings.creditAmount] || '';
                const transactionType = row[mappings.transactionType] || '';
                const category = row[mappings.category] || 'Uncategorized';

                if (!dateStr || !description) {
                    skippedCount++;
                    importErrors.push(`Row ${index + 2}: Missing required fields (date or description)`);
                    return;
                }
                
                if (!amountStr && !creditAmountStr) {
                    skippedCount++;
                    importErrors.push(`Row ${index + 2}: Missing amount value`);
                    return;
                }

                // Parse date with multiple format support
                let date;
                try {
                    // Try different date formats
                    let parsedDate;
                    
                    // Check for MM/DD/YYYY, MM-DD-YYYY, etc.
                    if (dateStr.match(/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}$/)) {
                        parsedDate = new Date(dateStr);
                    }
                    // Check for YYYY-MM-DD
                    else if (dateStr.match(/^\d{4}-\d{1,2}-\d{1,2}$/)) {
                        parsedDate = new Date(dateStr);
                    }
                    // Check for DD/MM/YYYY (European format)
                    else if (dateStr.match(/^\d{1,2}[\/\-]\d{1,2}[\/\-]\d{4}$/) && dateStr.split(/[\/\-]/)[0] > 12) {
                        const parts = dateStr.split(/[\/\-]/);
                        parsedDate = new Date(`${parts[1]}/${parts[0]}/${parts[2]}`);
                    }
                    else {
                        parsedDate = new Date(dateStr);
                    }
                    
                    if (isNaN(parsedDate.getTime())) {
                        throw new Error('Invalid date');
                    }
                    
                    date = parsedDate.toISOString().split('T')[0];
                } catch (e) {
                    skippedCount++;
                    importErrors.push(`Row ${index + 2}: Invalid date "${dateStr}"`);
                    return;
                }

                // Parse amount - handle both debit and credit columns
                let amount = 0;
                let hasDebit = false;
                let hasCredit = false;
                let hasAmount = false;

                // Parse debit column (expenses/charges)
                if (amountStr && amountStr.trim()) {
                    const debitValue = parseFloat(amountStr.replace(/[$,\s()]/g, '').replace(/[^\d.-]/g, ''));
                    if (!isNaN(debitValue) && debitValue !== 0) {
                        amount = -Math.abs(debitValue); // Debits are negative (expenses)
                        hasDebit = true;
                        hasAmount = true;
                    }
                }

                // Parse credit column (payments/income coming in)
                if (creditAmountStr && creditAmountStr.trim()) {
                    const creditValue = parseFloat(creditAmountStr.replace(/[$,\s()]/g, '').replace(/[^\d.-]/g, ''));
                    if (!isNaN(creditValue) && creditValue !== 0) {
                        amount = Math.abs(creditValue); // Credits are positive (income/payments in)
                        hasCredit = true;
                        hasAmount = true;
                    }
                }

                // If neither column has a value, skip this row
                if (!hasAmount) {
                    skippedCount++;
                    importErrors.push(`Row ${index + 2}: No amount found in debit or credit columns`);
                    return;
                }

                if (isNaN(amount)) {
                    skippedCount++;
                    importErrors.push(`Row ${index + 2}: Invalid amount value`);
                    return;
                }

                // Use transaction type to determine sign when applicable
                // This handles CSVs with a single amount column and a type column indicating debit/credit
                if (mappings.transactionType && transactionType) {
                    const type = transactionType.toLowerCase();

                    // If using separate debit/credit columns, don't override their signs
                    // Only use transaction type when there's a single amount column (not separate debit/credit columns)
                    const usingSeparateColumns = (mappings.amount && mappings.creditAmount);

                    if (usingSeparateColumns) {
                        // Just validate, don't change the sign (column determines sign)
                        if ((type.includes('payment') || type.includes('credit')) && amount < 0 && hasCredit) {
                            console.warn(`Row ${index + 2}: Category says "${transactionType}" but amount is in credit column`);
                        } else if (type.includes('debit') && amount > 0 && hasDebit) {
                            console.warn(`Row ${index + 2}: Category says "${transactionType}" but amount is in debit column`);
                        }
                    } else {
                        // Single amount column - use transaction type to determine sign
                        if (type.includes('credit') || type.includes('deposit')) {
                            // Credits/deposits should be positive (income)
                            amount = Math.abs(amount);
                        } else if (type.includes('debit') || type.includes('withdrawal') || type.includes('charge') || type.includes('payment')) {
                            // Debits/withdrawals/payments should be negative (expenses)
                            amount = -Math.abs(amount);
                        }
                    }
                }

                // Apply categorization rules
                const appliedCategory = applyCategorationRules(description, category);

                const transaction = {
                    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                    date: date,
                    description: description.trim(),
                    amount: amount,
                    category: appliedCategory,
                    transactionType: transactionType,
                    accountType: accountType,
                    imported: true,
                    importDate: new Date().toISOString()
                };

                // Check for duplicates with smart handling
                const potentialDuplicate = transactions.find(t => 
                    t.date === transaction.date && 
                    t.description.toLowerCase() === transaction.description.toLowerCase() && 
                    Math.abs(t.amount - transaction.amount) < 0.01
                );

                if (potentialDuplicate && !potentialDuplicate.isDuplicateFlag) {
                    // Mark both transactions as potential duplicates
                    transaction.isDuplicateFlag = true;
                    transaction.duplicateGroup = potentialDuplicate.id;
                    transaction.excludeFromTotals = true;
                    
                    potentialDuplicate.isDuplicateFlag = true;
                    potentialDuplicate.duplicateGroup = potentialDuplicate.id; // Group leader
                    potentialDuplicate.excludeFromTotals = true;
                    
                    transactions.push(transaction);
                    importedCount++;
                    skippedCount++; // Also count as flagged
                    importErrors.push(`Row ${index + 2}: Potential duplicate flagged for review`);

                    // Detect potential subscriptions (negative amounts, recurring patterns)
                    if (amount < 0) {
                        detectSubscription(transaction, detectedSubscriptions);
                    }
                } else if (potentialDuplicate && potentialDuplicate.isDuplicateFlag) {
                    // Add to existing duplicate group
                    transaction.isDuplicateFlag = true;
                    transaction.duplicateGroup = potentialDuplicate.duplicateGroup;
                    transaction.excludeFromTotals = true;
                    
                    transactions.push(transaction);
                    importedCount++;
                    importErrors.push(`Row ${index + 2}: Added to duplicate group for review`);
                } else {
                    // No duplicate, import normally
                    transactions.push(transaction);
                    importedCount++;

                    // Detect potential subscriptions (negative amounts, recurring patterns)
                    if (amount < 0) {
                        detectSubscription(transaction, detectedSubscriptions);
                    }
                }
            });

            // Process detected subscriptions
            if (detectedSubscriptions.length > 0) {
                processDetectedSubscriptions(detectedSubscriptions);
            }

            // Show detailed results
            let message = `Import completed!\n\n`;
            message += `✅ Imported: ${importedCount} transactions\n`;
            if (skippedCount > 0) {
                message += `⚠️ Skipped: ${skippedCount} transactions (duplicates or errors)\n`;
            }
            if (detectedSubscriptions.length > 0) {
                message += `📄 Found: ${detectedSubscriptions.length} potential subscriptions\n`;
            }
            if (importErrors.length > 0 && importErrors.length <= 5) {
                message += `\nErrors:\n${importErrors.slice(0, 5).join('\n')}`;
            } else if (importErrors.length > 5) {
                message += `\nFirst 5 errors:\n${importErrors.slice(0, 5).join('\n')}\n... and ${importErrors.length - 5} more`;
            }

            alert(message);

            if (importedCount > 0) {
                updateDashboard();
                updateTransactionsTable();
                updateSubscriptionsView();
                saveUserData();
            }
            
            // Reset the import form
            document.getElementById('mappingSection').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            csvData = [];
            csvHeaders = [];
        }

        function applyCategorationRules(description, defaultCategory) {
            const desc = description.toLowerCase();
            
            // Apply rules in order of priority
            for (const rule of rules) {
                if (rule.conditions.some(condition => {
                    switch (condition.type) {
                        case 'contains':
                            return desc.includes(condition.value.toLowerCase());
                        case 'starts_with':
                            return desc.startsWith(condition.value.toLowerCase());
                        case 'ends_with':
                            return desc.endsWith(condition.value.toLowerCase());
                        case 'equals':
                            return desc === condition.value.toLowerCase();
                        default:
                            return false;
                    }
                })) {
                    return rule.category;
                }
            }
            
            return defaultCategory;
        }

        function processDetectedSubscriptions(detectedSubscriptions) {
    detectedSubscriptions.forEach(detected => {
        // Check if subscription already exists
        const existingSubscription = subscriptions.find(sub => 
            sub.vendor.toLowerCase() === detected.vendor.toLowerCase()
        );

        if (!existingSubscription) {
            // Calculate frequency based on transaction dates
            let frequency = 'monthly'; // default
            if (detected.transactions.length > 1) {
                const dates = detected.transactions.map(t => new Date(t.date)).sort();
                const daysBetween = (dates[1] - dates[0]) / (1000 * 60 * 60 * 24);
                if (daysBetween > 300) frequency = 'annual';
                else if (daysBetween > 80) frequency = 'quarterly';
                else frequency = 'monthly';
            }

            subscriptions.push({
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                vendor: detected.vendor,
                amount: detected.amount,
                frequency: frequency,
                category: detected.category,
                lastCharge: detected.lastDate,
                nextCharge: calculateNextChargeFromDate(detected.lastDate, frequency),
                status: 'active',
                autoDetected: true,
                priceChanged: detected.priceChanged,
                newAmount: detected.newAmount || detected.amount,
                aliases: [],
                suggestedAliases: [],
                detectedDate: new Date().toISOString()
            });
        } else if (detected.priceChanged) {
            // Update existing subscription with new amount
            existingSubscription.amount = detected.newAmount;
            existingSubscription.priceChanged = true;
            existingSubscription.lastCharge = detected.lastDate;
        }
    });
}

        // Subscription management functions with inline forms
        function toggleAddSubscriptionForm() {
            const form = document.getElementById('addSubscriptionForm');
            const editForm = document.getElementById('editSubscriptionForm');
            
            // Hide edit form if open
            if (!editForm.classList.contains('hidden')) {
                editForm.classList.add('hidden');
            }
            
            if (form.classList.contains('hidden')) {
                // Show form and populate categories
                form.classList.remove('hidden');
                populateSubscriptionCategories('newSubCategory');

                // Clear form
                document.getElementById('newSubVendor').value = '';
                document.getElementById('newSubAmount').value = '';
                document.getElementById('newSubFrequency').value = 'monthly';
                document.getElementById('newSubAliases').value = '';
                document.getElementById('newSubPatternType').value = '';
                document.getElementById('newSubPatternValue').value = '';

                // Scroll to form
                form.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                form.classList.add('hidden');
            }
        }

        function populateSubscriptionCategories(selectId) {
            const select = document.getElementById(selectId);
            if (!select) return;
            
            select.innerHTML = categories.expense.map(cat => 
                `<option value="${cat}">${cat}</option>`
            ).join('');
        }

        function saveNewSubscription() {
            const vendor = document.getElementById('newSubVendor').value.trim();
            const amount = parseFloat(document.getElementById('newSubAmount').value);
            const frequency = document.getElementById('newSubFrequency').value;
            const category = document.getElementById('newSubCategory').value;
            const aliasesStr = document.getElementById('newSubAliases').value.trim();
            const patternType = document.getElementById('newSubPatternType').value;
            const patternValue = document.getElementById('newSubPatternValue').value.trim();

            // Validation
            if (!vendor) {
                alert('Please enter a vendor/service name');
                document.getElementById('newSubVendor').focus();
                return;
            }

            if (isNaN(amount) || amount <= 0) {
                alert('Please enter a valid amount');
                document.getElementById('newSubAmount').focus();
                return;
            }

            // Validate pattern
            if (patternType && !patternValue) {
                alert('Please enter a pattern value or clear the pattern type');
                document.getElementById('newSubPatternValue').focus();
                return;
            }

            // Parse aliases
            const aliases = aliasesStr ? aliasesStr.split(',').map(a => a.trim()).filter(a => a) : [];

            const subscription = {
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                vendor: vendor,
                amount: amount,
                frequency: frequency,
                category: category,
                status: 'active',
                nextCharge: calculateNextCharge(frequency),
                autoDetected: false,
                aliases: aliases,
                suggestedAliases: [],
                pattern: patternType && patternValue ? { type: patternType, value: patternValue } : null,
                created: new Date().toISOString()
            };

            subscriptions.push(subscription);
            updateSubscriptionsView();
            saveUserData();

            // Hide form
            document.getElementById('addSubscriptionForm').classList.add('hidden');

            alert(`Subscription "${vendor}" added successfully!`);
        }

        function cancelAddSubscription() {
            document.getElementById('addSubscriptionForm').classList.add('hidden');
        }

        function editSubscription(subscriptionId) {
            const subscription = subscriptions.find(sub => sub.id === subscriptionId);
            if (!subscription) return;

            // Hide add form if open
            const addForm = document.getElementById('addSubscriptionForm');
            if (!addForm.classList.contains('hidden')) {
                addForm.classList.add('hidden');
            }

            // Show and populate edit form
            const form = document.getElementById('editSubscriptionForm');
            form.classList.remove('hidden');
            
            populateSubscriptionCategories('editSubCategory');
            
            document.getElementById('editSubVendor').value = subscription.vendor;
            document.getElementById('editSubAmount').value = subscription.amount;
            document.getElementById('editSubFrequency').value = subscription.frequency;
            document.getElementById('editSubCategory').value = subscription.category;
            document.getElementById('editSubAliases').value = (subscription.aliases || []).join(', ');
            document.getElementById('editSubPatternType').value = subscription.pattern ? subscription.pattern.type : '';
            document.getElementById('editSubPatternValue').value = subscription.pattern ? subscription.pattern.value : '';

            // Store ID for saving
            form.setAttribute('data-editing-id', subscriptionId);

            // Scroll to form
            form.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function saveSubscriptionEdit() {
            const form = document.getElementById('editSubscriptionForm');
            const subscriptionId = form.getAttribute('data-editing-id');
            const subscription = subscriptions.find(sub => sub.id === subscriptionId);
            
            if (!subscription) {
                alert('Subscription not found');
                return;
            }

            const vendor = document.getElementById('editSubVendor').value.trim();
            const amount = parseFloat(document.getElementById('editSubAmount').value);
            const frequency = document.getElementById('editSubFrequency').value;
            const category = document.getElementById('editSubCategory').value;
            const aliasesStr = document.getElementById('editSubAliases').value.trim();
            const patternType = document.getElementById('editSubPatternType').value;
            const patternValue = document.getElementById('editSubPatternValue').value.trim();

            // Validation
            if (!vendor) {
                alert('Please enter a vendor/service name');
                return;
            }

            if (isNaN(amount) || amount <= 0) {
                alert('Please enter a valid amount');
                return;
            }

            // Validate pattern
            if (patternType && !patternValue) {
                alert('Please enter a pattern value or clear the pattern type');
                return;
            }

            // Parse aliases
            const aliases = aliasesStr ? aliasesStr.split(',').map(a => a.trim()).filter(a => a) : [];

            // Update subscription
            subscription.vendor = vendor;
            subscription.amount = amount;
            subscription.frequency = frequency;
            subscription.category = category;
            subscription.aliases = aliases;
            subscription.pattern = patternType && patternValue ? { type: patternType, value: patternValue } : null;
            subscription.nextCharge = calculateNextCharge(frequency);
            subscription.updated = new Date().toISOString();

            updateSubscriptionsView();
            saveUserData();
            cancelEditSubscription();
            
            alert(`Subscription "${vendor}" updated successfully!`);
        }

        function cancelEditSubscription() {
            const form = document.getElementById('editSubscriptionForm');
            form.classList.add('hidden');
            form.removeAttribute('data-editing-id');
        }

        function calculateNextCharge(frequency) {
            const now = new Date();
            switch (frequency) {
                case 'monthly':
                    return new Date(now.getFullYear(), now.getMonth() + 1, now.getDate()).toISOString().split('T')[0];
                case 'quarterly':
                    return new Date(now.getFullYear(), now.getMonth() + 3, now.getDate()).toISOString().split('T')[0];
                case 'annual':
                    return new Date(now.getFullYear() + 1, now.getMonth(), now.getDate()).toISOString().split('T')[0];
                default:
                    return new Date(now.getFullYear(), now.getMonth() + 1, now.getDate()).toISOString().split('T')[0];
            }
        }

        function calculateNextChargeFromDate(lastChargeDate, frequency) {
    const lastDate = new Date(lastChargeDate);
    switch (frequency) {
        case 'monthly':
            return new Date(lastDate.getFullYear(), lastDate.getMonth() + 1, lastDate.getDate()).toISOString().split('T')[0];
        case 'quarterly':
            return new Date(lastDate.getFullYear(), lastDate.getMonth() + 3, lastDate.getDate()).toISOString().split('T')[0];
        case 'annual':
            return new Date(lastDate.getFullYear() + 1, lastDate.getMonth(), lastDate.getDate()).toISOString().split('T')[0];
        default:
            return new Date(lastDate.getFullYear(), lastDate.getMonth() + 1, lastDate.getDate()).toISOString().split('T')[0];
    }
}

        function updateSubscriptionsView() {
            const subscriptionsList = document.getElementById('subscriptionsList');
            
            if (subscriptions.length === 0) {
                subscriptionsList.innerHTML = '<p>No subscriptions found. Add subscriptions manually or import transactions to auto-detect them.</p>';
                return;
            }

            // Calculate totals and get next 30 days
const now = new Date();
const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

const monthlyTotal = subscriptions
    .filter(sub => sub.status === 'active')
    .reduce((total, sub) => {
        switch (sub.frequency) {
            case 'monthly': return total + sub.amount;
            case 'quarterly': return total + (sub.amount / 3);
            case 'annual': return total + (sub.amount / 12);
            default: return total + sub.amount;
        }
    }, 0);

const annualTotal = monthlyTotal * 12;

// Calculate upcoming charges in next 30 days
const upcomingCharges = subscriptions
    .filter(sub => {
        if (sub.status !== 'active' || !sub.nextCharge) return false;
        const nextChargeDate = new Date(sub.nextCharge);
        return nextChargeDate >= now && nextChargeDate <= thirtyDaysFromNow;
    })
    .sort((a, b) => new Date(a.nextCharge) - new Date(b.nextCharge));

const upcomingTotal = upcomingCharges.reduce((total, sub) => total + sub.amount, 0);

// Get current month income
const metrics = calculateIncomeMetrics();
const currentIncome = metrics.currentMonthIncome;
const incomeNeeded = upcomingTotal;
const incomeProgress = incomeNeeded > 0 ? (currentIncome / incomeNeeded) * 100 : 100;

subscriptionsList.innerHTML = `
    <div class="grid" style="margin-bottom: 20px;">
        <div class="stat-card">
            <div class="stat-value">${formatCurrency(monthlyTotal)}</div>
            <div class="stat-label">Monthly Total</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">${formatCurrency(annualTotal)}</div>
            <div class="stat-label">Annual Total</div>
        </div>
        <div class="stat-card" style="background: ${incomeProgress >= 100 ? 'linear-gradient(135deg, #059669 0%, #047857 100%)' : 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)'};">
            <div class="stat-value">${formatCurrency(upcomingTotal)}</div>
            <div class="stat-label">Due in Next 30 Days</div>
        </div>
    </div>

    ${upcomingCharges.length > 0 ? `
        <div class="card" style="margin-bottom: 20px; ${incomeProgress >= 100 ? 'background: #f0fff4; border: 2px solid #059669;' : 'background: #fef3cd; border: 2px solid #f59e0b;'}">
            <h4 style="margin-bottom: 15px;">📅 Upcoming Charges (Next 30 Days)</h4>
            
            <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 6px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span style="font-weight: bold;">Income Progress:</span>
                    <span style="font-weight: bold; color: ${incomeProgress >= 100 ? '#059669' : '#f59e0b'};">
                        ${formatCurrency(currentIncome)} / ${formatCurrency(incomeNeeded)} (${incomeProgress.toFixed(0)}%)
                    </span>
                </div>
                <div style="width: 100%; height: 20px; background: #e2e8f0; border-radius: 10px; overflow: hidden;">
                    <div style="width: ${Math.min(incomeProgress, 100)}%; height: 100%; background: ${incomeProgress >= 100 ? '#059669' : '#f59e0b'}; transition: width 0.3s ease;"></div>
                </div>
                ${incomeProgress >= 100 ? 
                    '<div style="margin-top: 10px; text-align: center; font-weight: bold; color: #059669;">🎉 Congratulations! You have enough income to cover upcoming subscriptions!</div>' :
                    `<div style="margin-top: 10px; text-align: center; font-weight: bold; color: #f59e0b;">⚠️ Need ${formatCurrency(incomeNeeded - currentIncome)} more to cover upcoming subscriptions</div>`
                }
            </div>
            
            ${upcomingCharges.map(sub => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #e2e8f0; background: white; margin-bottom: 5px; border-radius: 4px;">
                    <div>
                        <strong>${sub.vendor}</strong>
                        <div style="font-size: 0.8em; color: #718096;">
                            Due: ${formatDate(sub.nextCharge)}
                        </div>
                    </div>
                    <div style="font-weight: bold; color: #e53e3e;">
                        ${formatCurrency(sub.amount)}
                    </div>
                </div>
            `).join('')}
        </div>
    ` : ''}

                <div class="card">
                    <h4>Active Subscriptions</h4>
                    ${subscriptions.filter(sub => sub.status === 'active').sort((a, b) => a.vendor.localeCompare(b.vendor)).map(sub => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #e2e8f0;">
                            <div>
                                <strong>${sub.vendor}</strong>
                                ${sub.autoDetected ? '<span style="background: #e6fffa; color: #234e52; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">Auto-detected</span>' : ''}
                                ${sub.priceChanged ? '<span style="background: #fed7d7; color: #742a2a; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 5px;">Price Changed</span>' : ''}
                                <br>
                                <small style="color: #718096;">
                                    ${formatCurrency(sub.amount)} ${sub.frequency} • ${sub.category}
                                    ${sub.nextCharge ? ` • Next: ${formatDate(sub.nextCharge)}` : ''}
                                    ${sub.lastCharge ? ` • Last: ${formatDate(sub.lastCharge)}` : ''}
                                </small>
                                ${sub.aliases && sub.aliases.length > 0 ? `
                                    <div style="margin-top: 5px;">
                                        ${sub.aliases.map(alias => `<span class="alias-tag">${alias}</span>`).join('')}
                                    </div>
                                ` : ''}
                                ${sub.pattern && sub.pattern.value ? `
                                    <div style="margin-top: 5px;">
                                        <span style="background: #dbeafe; color: #1e40af; padding: 2px 8px; border-radius: 12px; font-size: 0.8em;">
                                            📋 Pattern: ${sub.pattern.type.replace('_', ' ')} "${sub.pattern.value}"
                                        </span>
                                    </div>
                                ` : ''}
                                ${sub.suggestedAliases && sub.suggestedAliases.length > 0 ? `
                                    <div style="margin-top: 5px;">
                                        <span style="font-size: 0.8em; color: #f59e0b;">⚠️ Suggested aliases:</span>
                                        ${sub.suggestedAliases.map(alias => `<span class="alias-tag suggested-alias">${alias}</span>`).join('')}
                                    </div>
                                ` : ''}
                            </div>
                            <div>
                                <button class="btn btn-secondary" onclick="editSubscription('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Edit</button>
                                <button class="btn" onclick="toggleSubscriptionStatus('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Pause</button>
                                <button class="btn btn-danger" onclick="deleteSubscription('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Delete</button>
                            </div>
                        </div>
                    `).join('')}
                </div>

                ${subscriptions.filter(sub => sub.status !== 'active').length > 0 ? `
                    <div class="card">
                        <h4>Paused/Cancelled Subscriptions</h4>
                        ${subscriptions.filter(sub => sub.status !== 'active').sort((a, b) => a.vendor.localeCompare(b.vendor)).map(sub => `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 1px solid #e2e8f0; opacity: 0.7;">
                                <div>
                                    <strong>${sub.vendor}</strong>
                                    <span style="background: #f7fafc; color: #4a5568; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px;">${sub.status}</span>
                                    <br>
                                    <small style="color: #718096;">
                                        ${formatCurrency(sub.amount)} ${sub.frequency} • ${sub.category}
                                    </small>
                                </div>
                                <div>
                                    <button class="btn btn-secondary" onclick="editSubscription('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Edit</button>
                                    <button class="btn" onclick="toggleSubscriptionStatus('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Reactivate</button>
                                    <button class="btn btn-danger" onclick="deleteSubscription('${sub.id}')" style="padding: 5px 10px; margin: 2px;">Delete</button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            `;
        }

        function toggleSubscriptionStatus(subscriptionId) {
            const subscription = subscriptions.find(sub => sub.id === subscriptionId);
            if (!subscription) return;

            subscription.status = subscription.status === 'active' ? 'paused' : 'active';
            if (subscription.status === 'active') {
                subscription.nextCharge = calculateNextCharge(subscription.frequency);
            }

            updateSubscriptionsView();
            saveUserData();
        }

        function deleteSubscription(subscriptionId) {
            const subscription = subscriptions.find(sub => sub.id === subscriptionId);
            if (!subscription) return;
            
            if (confirm(`Delete subscription "${subscription.vendor}"?`)) {
                subscriptions = subscriptions.filter(sub => sub.id !== subscriptionId);
                updateSubscriptionsView();
                saveUserData();
            }
        }

        // Subscription merge management functions
        function showMergeManager() {
            const dialog = document.getElementById('mergeDialog');
            const list = document.getElementById('mergeSubscriptionsList');
            
            list.innerHTML = subscriptions.map(sub => `
                <div class="subscription-item" data-id="${sub.id}" onclick="toggleSubscriptionSelection('${sub.id}')">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <strong>${sub.vendor}</strong>
                            <span style="color: #718096; margin-left: 10px;">${formatCurrency(sub.amount)}</span>
                            ${sub.aliases && sub.aliases.length > 0 ? `
                                <div style="margin-top: 5px;">
                                    ${sub.aliases.map(alias => `<span class="alias-tag">${alias}</span>`).join('')}
                                </div>
                            ` : ''}
                        </div>
                        <input type="checkbox" style="margin-left: 10px;">
                    </div>
                </div>
            `).join('');
            
            dialog.classList.remove('hidden');
        }

        function toggleSubscriptionSelection(subscriptionId) {
            const item = document.querySelector(`[data-id="${subscriptionId}"]`);
            const checkbox = item.querySelector('input[type="checkbox"]');
            
            checkbox.checked = !checkbox.checked;
            item.classList.toggle('selected', checkbox.checked);
            
            updateMergeButton();
        }

        function updateMergeButton() {
            const selected = document.querySelectorAll('.subscription-item.selected').length;
            const mergeBtn = document.getElementById('mergeBtn');
            
            mergeBtn.disabled = selected < 2;
            mergeBtn.textContent = selected < 2 ? 'Select at least 2 subscriptions' : `Merge ${selected} Subscriptions`;
        }

        function executeMerge() {
            const selectedItems = document.querySelectorAll('.subscription-item.selected');
            const selectedIds = Array.from(selectedItems).map(item => item.dataset.id);
            
            if (selectedIds.length < 2) {
                alert('Please select at least 2 subscriptions to merge');
                return;
            }

            const selectedSubscriptions = subscriptions.filter(sub => selectedIds.includes(sub.id));
            const primarySubscription = selectedSubscriptions[0]; // First selected becomes primary
            const toMerge = selectedSubscriptions.slice(1);

            // Initialize aliases if not present
            if (!primarySubscription.aliases) primarySubscription.aliases = [];

            // Add new alias if provided
            const newAlias = document.getElementById('newAliasInput').value.trim();
            if (newAlias) {
                if (!primarySubscription.aliases.includes(newAlias)) {
                    primarySubscription.aliases.push(newAlias);
                }
            }

            // Merge aliases from other subscriptions
            toMerge.forEach(sub => {
                // Add the vendor name as an alias
                if (!primarySubscription.aliases.includes(sub.vendor)) {
                    primarySubscription.aliases.push(sub.vendor);
                }
                
                // Add existing aliases
                if (sub.aliases) {
                    sub.aliases.forEach(alias => {
                        if (!primarySubscription.aliases.includes(alias)) {
                            primarySubscription.aliases.push(alias);
                        }
                    });
                }

                // Merge suggested aliases
                if (sub.suggestedAliases) {
                    if (!primarySubscription.suggestedAliases) primarySubscription.suggestedAliases = [];
                    sub.suggestedAliases.forEach(alias => {
                        if (!primarySubscription.suggestedAliases.includes(alias)) {
                            primarySubscription.suggestedAliases.push(alias);
                        }
                    });
                }

                // Update amount if the merged subscription has a higher amount (likely more recent)
                if (sub.amount > primarySubscription.amount) {
                    primarySubscription.amount = sub.amount;
                }

                // Use the most recent charge date
                if (sub.lastCharge && (!primarySubscription.lastCharge || sub.lastCharge > primarySubscription.lastCharge)) {
                    primarySubscription.lastCharge = sub.lastCharge;
                }
            });

            // Remove merged subscriptions
            subscriptions = subscriptions.filter(sub => !selectedIds.slice(1).includes(sub.id));

            updateSubscriptionsView();
            closeMergeDialog();
            saveUserData();
            
            alert(`Successfully merged ${selectedIds.length} subscriptions into "${primarySubscription.vendor}"`);
        }

        function closeMergeDialog() {
            document.getElementById('mergeDialog').classList.add('hidden');
            document.getElementById('newAliasInput').value = '';
            
            // Clear selections
            document.querySelectorAll('.subscription-item').forEach(item => {
                item.classList.remove('selected');
                item.querySelector('input[type="checkbox"]').checked = false;
            });
        }

        // Suggested aliases management
        function reviewSuggestedAliases() {
            const dialog = document.getElementById('aliasDialog');
            const list = document.getElementById('suggestedAliasesList');
            
            const subscriptionsWithSuggestions = subscriptions.filter(sub => 
                sub.suggestedAliases && sub.suggestedAliases.length > 0
            );

            if (subscriptionsWithSuggestions.length === 0) {
                alert('No suggested aliases found. Import more transactions to see suggestions.');
                return;
            }

            list.innerHTML = subscriptionsWithSuggestions.map(sub => `
                <div class="card" style="margin-bottom: 15px;">
                    <h4>${sub.vendor}</h4>
                    <p style="margin-bottom: 10px;">Suggested aliases based on transaction descriptions:</p>
                    ${sub.suggestedAliases.map(alias => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; border: 1px solid #e2e8f0; border-radius: 4px; margin-bottom: 5px;">
                            <span>${alias}</span>
                            <div>
                                <button class="btn" onclick="acceptAlias('${sub.id}', '${alias.replace(/'/g, "\\'")}');reviewSuggestedAliases();" style="padding: 4px 8px; font-size: 0.8em;">Accept</button>
                                <button class="btn btn-danger" onclick="rejectAlias('${sub.id}', '${alias.replace(/'/g, "\\'")}');reviewSuggestedAliases();" style="padding: 4px 8px; font-size: 0.8em;">Reject</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `).join('');
            
            dialog.classList.remove('hidden');
        }

        function acceptAlias(subscriptionId, alias) {
            const subscription = subscriptions.find(sub => sub.id === subscriptionId);
            if (!subscription) return;

            // Move from suggested to accepted aliases
            if (!subscription.aliases) subscription.aliases = [];
            if (!subscription.aliases.includes(alias)) {
                subscription.aliases.push(alias);
            }
            
            subscription.suggestedAliases = subscription.suggestedAliases.filter(a => a !== alias);
            
            updateSubscriptionsView();
            saveUserData();
        }

        function rejectAlias(subscriptionId, alias) {
            const subscription = subscriptions.find(sub => sub.id === subscriptionId);
            if (!subscription) return;

            subscription.suggestedAliases = subscription.suggestedAliases.filter(a => a !== alias);
            
            saveUserData();
        }

        function closeAliasDialog() {
            document.getElementById('aliasDialog').classList.add('hidden');
        }

        // Other functions
        function addCategory(type) { 
            toggleAddCategoryForm(type);
        }

        function toggleAddCategoryForm(type) {
            const form = document.getElementById(`add${type.charAt(0).toUpperCase() + type.slice(1)}CategoryForm`);
            const input = document.getElementById(`new${type.charAt(0).toUpperCase() + type.slice(1)}Category`);
            
            if (form.classList.contains('hidden')) {
                form.classList.remove('hidden');
                input.value = '';
                input.focus();
            } else {
                form.classList.add('hidden');
            }
        }

        function saveNewCategory(type) {
            const input = document.getElementById(`new${type.charAt(0).toUpperCase() + type.slice(1)}Category`);
            const name = input.value.trim();
            
            if (!name) {
                alert('Please enter a category name');
                return;
            }
            
            if (categories[type].includes(name)) {
                alert('Category already exists');
                return;
            }
            
            categories[type].push(name);
            updateCategoriesView();
            saveUserData();
            
            // Hide the form
            document.getElementById(`add${type.charAt(0).toUpperCase() + type.slice(1)}CategoryForm`).classList.add('hidden');
        }

        function cancelAddCategory(type) {
            document.getElementById(`add${type.charAt(0).toUpperCase() + type.slice(1)}CategoryForm`).classList.add('hidden');
        }

        function deleteCategory(type, name) {
            if (confirm(`Delete "${name}" category?`)) {
                categories[type] = categories[type].filter(cat => cat !== name);
                updateCategoriesView();
                saveUserData();
            }
        }

        function showAddTransactionForm() {
            // Hide edit form if it's open
            document.getElementById('editTransactionForm').classList.add('hidden');

            // Show the add form
            const form = document.getElementById('addTransactionForm');
            form.classList.remove('hidden');

            // Set today's date as default
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('addTransactionDate').value = today;

            // Clear other fields
            document.getElementById('addTransactionDescription').value = '';
            document.getElementById('addTransactionAmount').value = '';

            // Populate categories dropdown
            const categorySelect = document.getElementById('addTransactionCategory');
            const incomeOptgroup = categorySelect.querySelector('optgroup[label="Income Categories"]');
            const expenseOptgroup = categorySelect.querySelector('optgroup[label="Expense Categories"]');

            incomeOptgroup.innerHTML = categories.income.map(cat =>
                `<option value="${cat}">${cat}</option>`
            ).join('');

            expenseOptgroup.innerHTML = categories.expense.map(cat =>
                `<option value="${cat}">${cat}</option>`
            ).join('');

            // Add Uncategorized option as default
            expenseOptgroup.innerHTML = '<option value="Uncategorized" selected>Uncategorized</option>' + expenseOptgroup.innerHTML;

            // Scroll to the form
            form.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function saveNewTransaction() {
            // Get form values
            const date = document.getElementById('addTransactionDate').value;
            const description = document.getElementById('addTransactionDescription').value.trim();
            const amount = parseFloat(document.getElementById('addTransactionAmount').value);
            const category = document.getElementById('addTransactionCategory').value;

            // Validate inputs
            if (!date) {
                alert('Please enter a date');
                return;
            }
            if (!description) {
                alert('Please enter a description');
                return;
            }
            if (isNaN(amount) || amount === 0) {
                alert('Please enter a valid amount (positive for income, negative for expenses)');
                return;
            }
            if (!category) {
                alert('Please select a category');
                return;
            }

            // Create new transaction
            const newTransaction = {
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                date: date,
                description: description,
                amount: amount,
                category: category,
                accountType: 'checking', // Default to checking
                imported: false,
                manualEntry: true,
                created: new Date().toISOString()
            };

            // Add to transactions array
            transactions.push(newTransaction);

            // Update displays and save
            updateDashboard();
            updateTransactionsTable();
            saveUserData();

            // Hide the form
            cancelAddTransaction();

            alert('Transaction added successfully!');
        }

        function cancelAddTransaction() {
            const form = document.getElementById('addTransactionForm');
            form.classList.add('hidden');
        }

        function editTransaction(id) {
            const transaction = transactions.find(t => t.id === id);
            if (!transaction) return;

            // Hide add form if it's open
            document.getElementById('addTransactionForm').classList.add('hidden');

            // Show the edit form
            const form = document.getElementById('editTransactionForm');
            form.classList.remove('hidden');

            // Populate the form
            document.getElementById('editTransactionDate').value = transaction.date;
            document.getElementById('editTransactionDescription').value = transaction.description;
            document.getElementById('editTransactionAmount').value = transaction.amount;

            // Populate categories dropdown
            const categorySelect = document.getElementById('editTransactionCategory');
            const incomeOptgroup = categorySelect.querySelector('optgroup[label="Income Categories"]');
            const expenseOptgroup = categorySelect.querySelector('optgroup[label="Expense Categories"]');

            incomeOptgroup.innerHTML = categories.income.map(cat =>
                `<option value="${cat}" ${transaction.category === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');

            expenseOptgroup.innerHTML = categories.expense.map(cat =>
                `<option value="${cat}" ${transaction.category === cat ? 'selected' : ''}>${cat}</option>`
            ).join('');

            // Add Uncategorized option
            if (!transaction.category || transaction.category === 'Uncategorized') {
                expenseOptgroup.innerHTML = '<option value="Uncategorized" selected>Uncategorized</option>' + expenseOptgroup.innerHTML;
            } else {
                expenseOptgroup.innerHTML = '<option value="Uncategorized">Uncategorized</option>' + expenseOptgroup.innerHTML;
            }

            // Store the transaction ID for saving
            form.setAttribute('data-editing-id', id);

            // Scroll to the form
            form.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function saveTransactionEdit() {
            const form = document.getElementById('editTransactionForm');
            const transactionId = form.getAttribute('data-editing-id');
            const transaction = transactions.find(t => t.id === transactionId);
            
            if (!transaction) {
                alert('Transaction not found');
                return;
            }

            // Get form values
            const newDate = document.getElementById('editTransactionDate').value;
            const newDescription = document.getElementById('editTransactionDescription').value.trim();
            const newAmount = parseFloat(document.getElementById('editTransactionAmount').value);
            const newCategory = document.getElementById('editTransactionCategory').value;

            // Validate inputs
            if (!newDate) {
                alert('Please enter a date');
                return;
            }
            if (!newDescription) {
                alert('Please enter a description');
                return;
            }
            if (isNaN(newAmount)) {
                alert('Please enter a valid amount');
                return;
            }
            if (!newCategory) {
                alert('Please select a category');
                return;
            }

            // Update the transaction
            transaction.date = newDate;
            transaction.description = newDescription;
            transaction.amount = newAmount;
            transaction.category = newCategory;
            transaction.lastModified = new Date().toISOString();

            // Update displays and save
            updateDashboard();
            updateTransactionsTable();
            saveUserData();
            
            // Hide the form
            cancelTransactionEdit();
            
            alert('Transaction updated successfully!');
        }

        function cancelTransactionEdit() {
            const form = document.getElementById('editTransactionForm');
            form.classList.add('hidden');
            form.removeAttribute('data-editing-id');
        }

        function deleteTransaction(id) { 
            const transaction = transactions.find(t => t.id === id);
            
            if (confirm('Delete this transaction?')) {
                // If this is part of a duplicate group, resolve the others
                if (transaction && transaction.isDuplicateFlag && transaction.duplicateGroup) {
                    const groupId = transaction.duplicateGroup;
                    const groupMembers = transactions.filter(t => t.duplicateGroup === groupId && t.id !== id);
                    
                    // If only one other transaction remains in the group, mark it as legitimate
                    if (groupMembers.length === 1) {
                        groupMembers[0].isDuplicateFlag = false;
                        groupMembers[0].excludeFromTotals = false;
                        delete groupMembers[0].duplicateGroup;
                    }
                    // If multiple remain, they stay flagged
                }
                
                transactions = transactions.filter(t => t.id !== id);
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
            }
        }

        function exportData() {
            const dataStr = JSON.stringify({
                transactions,
                categories,
                rules,
                subscriptions,
                seasonalFactors,
                projectionHistory,
                exportDate: new Date().toISOString()
            }, null, 2);
            
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `financial-data-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (confirm('This will overwrite your current data. Continue?')) {
                            transactions = data.transactions || [];
                            categories = data.categories || categories;
                            rules = data.rules || [];
                            subscriptions = data.subscriptions || [];
                            seasonalFactors = data.seasonalFactors || {};
                            projectionHistory = data.projectionHistory || {};
                            
                            updateDashboard();
                            updateTransactionsTable();
                            updateCategoriesView();
                            updateRulesView();
                            updateSubscriptionsView();
                            saveUserData();
                            
                            alert('Data imported successfully!');
                        }
                    } catch (error) {
                        alert('Invalid file format.');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function addRule() { 
            toggleAddRuleForm();
        }

        function toggleAddRuleForm() {
            const form = document.getElementById('addRuleForm');
            const isHidden = form.classList.contains('hidden');
            
            if (isHidden) {
                // Show the form and populate categories
                form.classList.remove('hidden');
                populateRuleCategoryDropdown();
                // Clear any previous values
                document.getElementById('newRuleName').value = '';
                document.getElementById('newRuleConditionValue').value = '';
                document.getElementById('newRuleConditionType').value = 'contains';
            } else {
                // Hide the form
                form.classList.add('hidden');
            }
        }

        function populateRuleCategoryDropdown() {
            const select = document.getElementById('newRuleCategory');
            const incomeOptgroup = select.querySelector('optgroup[label="Income Categories"]');
            const expenseOptgroup = select.querySelector('optgroup[label="Expense Categories"]');
            
            incomeOptgroup.innerHTML = categories.income.map(cat => 
                `<option value="${cat}">${cat}</option>`
            ).join('');
            
            expenseOptgroup.innerHTML = categories.expense.map(cat => 
                `<option value="${cat}">${cat}</option>`
            ).join('');
        }

        function saveNewRule() {
            const name = document.getElementById('newRuleName').value.trim();
            const conditionType = document.getElementById('newRuleConditionType').value;
            const conditionValue = document.getElementById('newRuleConditionValue').value.trim();
            const category = document.getElementById('newRuleCategory').value;

            // Validate inputs
            if (!name) {
                alert('Please enter a rule name');
                return;
            }
            if (!conditionValue) {
                alert('Please enter text to match');
                return;
            }
            if (!category) {
                alert('Please select a category');
                return;
            }

            const rule = {
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                name: name,
                conditions: [{
                    type: conditionType,
                    value: conditionValue
                }],
                category: category,
                active: true,
                created: new Date().toISOString()
            };

            rules.push(rule);
            updateRulesView();
            saveUserData();
            
            // Hide the form
            document.getElementById('addRuleForm').classList.add('hidden');
            
            // Show success message
            alert(`Rule "${name}" created successfully!`);
        }

        function cancelAddRule() {
            document.getElementById('addRuleForm').classList.add('hidden');
        }

        function updateRulesView() {
            const rulesList = document.getElementById('rulesList');

            // Sort rules alphabetically by name
            const sortedRules = [...rules].sort((a, b) => a.name.localeCompare(b.name));

            rulesList.innerHTML = sortedRules.length ? sortedRules.map(rule => `
                <div class="card" style="margin-bottom: 15px; ${!rule.active ? 'opacity: 0.6;' : ''}">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <h4 style="margin: 0; color: ${rule.active ? '#4a5568' : '#a0aec0'};">${rule.name}</h4>
                            <p style="margin: 5px 0; font-size: 0.9em; color: #718096;">
                                If description <strong>${rule.conditions[0].type.replace('_', ' ')}</strong> 
                                "<strong>${rule.conditions[0].value}</strong>" → 
                                Set category to <strong>${rule.category}</strong>
                            </p>
                            <small style="color: #a0aec0;">Created: ${formatDate(rule.created)}</small>
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button class="btn ${rule.active ? 'btn-secondary' : ''}" onclick="toggleRule('${rule.id}')" style="padding: 8px 12px;">
                                ${rule.active ? 'Disable' : 'Enable'}
                            </button>
                            <button class="btn btn-secondary" onclick="editRule('${rule.id}')" style="padding: 8px 12px;">Edit</button>
                            <button class="btn btn-danger" onclick="deleteRule('${rule.id}')" style="padding: 8px 12px;">Delete</button>
                        </div>
                    </div>
                </div>
            `).join('') : '<p>No rules created yet. Rules help automatically categorize transactions based on description patterns.</p>';
        }

        function toggleRule(ruleId) {
            const rule = rules.find(r => r.id === ruleId);
            if (rule) {
                rule.active = !rule.active;
                updateRulesView();
                saveUserData();
            }
        }

        function editRule(ruleId) {
            const rule = rules.find(r => r.id === ruleId);
            if (!rule) return;

            // Show the edit form (we'll reuse the add form)
            const form = document.getElementById('addRuleForm');
            form.classList.remove('hidden');
            populateRuleCategoryDropdown();
            
            // Populate with existing values
            document.getElementById('newRuleName').value = rule.name;
            document.getElementById('newRuleConditionType').value = rule.conditions[0].type;
            document.getElementById('newRuleConditionValue').value = rule.conditions[0].value;
            document.getElementById('newRuleCategory').value = rule.category;
            
            // Change the save button to update
            const saveButton = form.querySelector('.btn[onclick="saveNewRule()"]');
            saveButton.textContent = 'Update Rule';
            saveButton.setAttribute('onclick', `updateRule('${ruleId}')`);
            
            // Change the form title
            form.querySelector('h4').textContent = 'Edit Rule';
        }

        function updateRule(ruleId) {
            const rule = rules.find(r => r.id === ruleId);
            if (!rule) return;

            const name = document.getElementById('newRuleName').value.trim();
            const conditionType = document.getElementById('newRuleConditionType').value;
            const conditionValue = document.getElementById('newRuleConditionValue').value.trim();
            const category = document.getElementById('newRuleCategory').value;

            // Validate inputs
            if (!name || !conditionValue || !category) {
                alert('Please fill in all fields');
                return;
            }

            // Update the rule
            rule.name = name;
            rule.conditions[0].type = conditionType;
            rule.conditions[0].value = conditionValue;
            rule.category = category;
            rule.updated = new Date().toISOString();

            updateRulesView();
            saveUserData();
            
            // Reset the form
            resetAddRuleForm();
            
            alert(`Rule "${name}" updated successfully!`);
        }

        function resetAddRuleForm() {
            const form = document.getElementById('addRuleForm');
            form.classList.add('hidden');
            
            // Reset the button and title
            const saveButton = form.querySelector('.btn[onclick*="Rule"]');
            saveButton.textContent = 'Save Rule';
            saveButton.setAttribute('onclick', 'saveNewRule()');
            form.querySelector('h4').textContent = 'Create New Rule';
        }

        function deleteRule(ruleId) {
            const rule = rules.find(r => r.id === ruleId);
            if (!rule) return;
            
            if (confirm(`Delete rule "${rule.name}"?`)) {
                rules = rules.filter(r => r.id !== ruleId);
                updateRulesView();
                saveUserData();
                alert('Rule deleted successfully!');
            }
        }

        function applyRulesToExistingTransactions() {
            if (!confirm('Apply current rules to all existing transactions? This will update categories for matching transactions.')) {
                return;
            }

            let updatedCount = 0;
            transactions.forEach(transaction => {
                const originalCategory = transaction.category;
                const newCategory = applyCategorationRules(transaction.description, originalCategory);
                if (newCategory !== originalCategory) {
                    transaction.category = newCategory;
                    updatedCount++;
                }
            });

            if (updatedCount > 0) {
                alert(`Updated ${updatedCount} transactions based on current rules.`);
                updateDashboard();
                updateTransactionsTable();
                saveUserData();
            } else {
                alert('No transactions were updated. Rules may not match any existing transactions.');
            }
        }

        function updateIncomeVsExpensesChart(monthlyIncome) {
            const container = document.getElementById('incomeVsExpensesChart');
            if (!container) return;

            // Create monthly data object with both income and expenses
            const monthlyData = {};
            
            // Process all transactions (not just income)
            const activeTransactions = transactions.filter(t => !t.excludeFromTotals);
            
            activeTransactions.forEach(t => {
                const date = new Date(t.date);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { income: 0, expenses: 0, net: 0 };
                }
                
                if (t.amount > 0) {
                    monthlyData[monthKey].income += t.amount;
                } else {
                    monthlyData[monthKey].expenses += Math.abs(t.amount);
                }
                
                monthlyData[monthKey].net = monthlyData[monthKey].income - monthlyData[monthKey].expenses;
            });

            const sortedMonths = Object.keys(monthlyData).sort().slice(-6); // Last 6 months
            
            if (sortedMonths.length === 0) {
                container.innerHTML = '<p>No transaction data available yet.</p>';
                return;
            }

            container.innerHTML = `
                <div style="padding: 10px 0;">
                    ${sortedMonths.map(month => {
                        const data = monthlyData[month];
                        const [year, monthNum] = month.split('-');
                        const monthName = new Date(year, monthNum - 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                        
                        return `
                            <div style="margin-bottom: 15px; padding: 10px; border: 1px solid #e2e8f0; border-radius: 6px;">
                                <div style="font-weight: bold; margin-bottom: 8px;">${monthName}</div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <span style="color: #059669;">💰 Income:</span>
                                    <span style="font-weight: bold; color: #059669;">${formatCurrency(data.income)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <span style="color: #dc2626;">💸 Expenses:</span>
                                    <span style="font-weight: bold; color: #dc2626;">${formatCurrency(data.expenses)}</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; padding-top: 5px; border-top: 1px solid #e2e8f0;">
                                    <span style="font-weight: bold;">Net Cash Flow:</span>
                                    <span style="font-weight: bold; color: ${data.net >= 0 ? '#059669' : '#dc2626'};">
                                        ${formatCurrency(data.net)}
                                    </span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function updateRunningBalanceChart(activeTransactions) {
            const container = document.getElementById('runningBalanceChart');
            if (!container) return;

            if (activeTransactions.length === 0) {
                container.innerHTML = '<p>No transactions available for running balance.</p>';
                return;
            }

            // Sort transactions by date
            const sortedTransactions = [...activeTransactions].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Calculate running balance
            let runningBalance = 0;
            const balanceData = sortedTransactions.map(t => {
                runningBalance += t.amount;
                return {
                    date: t.date,
                    balance: runningBalance,
                    description: t.description,
                    amount: t.amount
                };
            });

            // Show last 10 transactions for running balance
            const recentBalances = balanceData.slice(-10);
            
            container.innerHTML = `
                <div style="max-height: 300px; overflow-y: auto;">
                    ${recentBalances.map((item, index) => {
                        const isPositive = item.amount >= 0;
                        const balancePositive = item.balance >= 0;
                        
                        return `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #e2e8f0;">
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; font-size: 0.9em;">${formatDate(item.date)}</div>
                                    <div style="font-size: 0.8em; color: #718096;">${item.description}</div>
                                </div>
                                <div style="text-align: center; margin: 0 15px;">
                                    <div style="font-size: 0.8em; color: ${isPositive ? '#059669' : '#dc2626'};">
                                        ${isPositive ? '+' : ''}${formatCurrency(item.amount)}
                                    </div>
                                </div>
                                <div style="text-align: right; min-width: 100px;">
                                    <div style="font-weight: bold; color: ${balancePositive ? '#059669' : '#dc2626'};">
                                        ${formatCurrency(item.balance)}
                                    </div>
                                    <div style="font-size: 0.7em; color: #a0aec0;">Balance</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <div style="margin-top: 15px; padding: 15px; background: ${balanceData[balanceData.length - 1]?.balance >= 0 ? '#f0fff4' : '#fef2f2'}; border-radius: 6px; text-align: center;">
                    <div style="font-size: 1.1em; font-weight: bold; color: ${balanceData[balanceData.length - 1]?.balance >= 0 ? '#059669' : '#dc2626'};">
                        Current Balance: ${formatCurrency(balanceData[balanceData.length - 1]?.balance || 0)}
                    </div>
                </div>
            `;
        }

        // Projection History Management Functions
        function showAddProjectionForm() {
            const form = document.getElementById('addProjectionForm');
            form.classList.remove('hidden');
            
            // Set default month to last month
            const lastMonth = new Date();
            lastMonth.setMonth(lastMonth.getMonth() - 1);
            document.getElementById('projectionMonth').value = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`;
            
            updateProjectionHistoryTable();
        }

        function cancelAddProjection() {
            document.getElementById('addProjectionForm').classList.add('hidden');
            // Clear form
            document.getElementById('projectionMonth').value = '';
            document.getElementById('projectionSeasonalFactor').value = '';
            document.getElementById('projectionBaseline').value = '';
            document.getElementById('projectionActual').value = '';
        }

        function saveProjectionData() {
            const month = document.getElementById('projectionMonth').value;
            const seasonalFactor = parseFloat(document.getElementById('projectionSeasonalFactor').value);
            const baseline = parseFloat(document.getElementById('projectionBaseline').value);
            const actual = parseFloat(document.getElementById('projectionActual').value);

            if (!month) {
                alert('Please select a month');
                return;
            }
            if (isNaN(seasonalFactor) || seasonalFactor < 0.1 || seasonalFactor > 3.0) {
                alert('Please enter a valid seasonal factor (0.1 - 3.0)');
                return;
            }
            if (isNaN(baseline) || baseline < 0) {
                alert('Please enter a valid baseline projection');
                return;
            }
            if (isNaN(actual) || actual < 0) {
                alert('Please enter a valid actual income');
                return;
            }

            const conservative = baseline * 0.75;
            const optimistic = baseline * 1.25;
            
            // Calculate accuracy vs Conservative target (our new goal)
            const conservativeDiff = Math.abs(actual - conservative);
            const baselineDiff = Math.abs(actual - baseline);
            const optimisticDiff = Math.abs(actual - optimistic);
            
            let accuracyType = 'vs Conservative';
            let accuracyPercentage = conservativeDiff / conservative * 100;
            let vsConservativeStatus = 'Met';
            
            if (actual >= conservative) {
                vsConservativeStatus = 'Met ✅';
                accuracyPercentage = ((actual - conservative) / conservative * 100);
            } else {
                vsConservativeStatus = 'Missed ❌';
                accuracyPercentage = ((conservative - actual) / conservative * 100);
            }

            projectionHistory[month] = {
                seasonalFactor: seasonalFactor,
                baseline: baseline,
                conservative: conservative,
                optimistic: optimistic,
                actual: actual,
                accuracyType: accuracyType,
                accuracyPercentage: accuracyPercentage,
                vsConservativeStatus: vsConservativeStatus,
                created: new Date().toISOString()
            };

            // Also update seasonal factors for this month
            seasonalFactors[month] = seasonalFactor;

            updateProjectionHistoryTable();
            updateSeasonalFactorHistory();
            saveUserData();
            cancelAddProjection();
            
            alert(`Projection data for ${month} saved successfully!`);
        }

        function updateProjectionHistoryTable() {
            const tbody = document.getElementById('projectionHistoryBody');
            if (!tbody) return;
            
            const sortedMonths = Object.keys(projectionHistory).sort().reverse(); // Newest first
            
            if (sortedMonths.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #718096;">No historical data yet. Add past month data to track accuracy.</td></tr>';
                return;
            }

            tbody.innerHTML = sortedMonths.map(month => {
                const data = projectionHistory[month];
                const [year, monthNum] = month.split('-');
                const monthName = new Date(year, monthNum - 1).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                
                // Determine Conservative target performance
                const metTarget = data.actual >= data.conservative;
                const targetColor = metTarget ? '#059669' : '#dc2626';
                const targetIcon = metTarget ? '✅' : '❌';
                const percentageDiff = metTarget 
                    ? `+${((data.actual - data.conservative) / data.conservative * 100).toFixed(1)}%`
                    : `-${((data.conservative - data.actual) / data.conservative * 100).toFixed(1)}%`;
                
                return `
                    <tr>
                        <td style="font-weight: bold;">${monthName}</td>
                        <td>${data.seasonalFactor.toFixed(1)}</td>
                        <td style="font-weight: bold; color: #dc2626;">${formatCurrency(data.conservative)}</td>
                        <td>${formatCurrency(data.baseline)}</td>
                        <td>${formatCurrency(data.optimistic)}</td>
                        <td style="font-weight: bold; color: ${targetColor};">${formatCurrency(data.actual)}</td>
                        <td style="color: ${targetColor};">
                            <div style="font-weight: bold;">${targetIcon} ${metTarget ? 'Met' : 'Missed'}</div>
                            <div style="font-size: 0.8em;">${percentageDiff}</div>
                        </td>
                        <td>
                            <button class="btn btn-secondary" onclick="editProjectionData('${month}')" style="padding: 3px 8px; font-size: 0.8em;">Edit</button>
                            <button class="btn btn-danger" onclick="deleteProjectionData('${month}')" style="padding: 3px 8px; font-size: 0.8em;">Delete</button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function editProjectionData(month) {
            const data = projectionHistory[month];
            if (!data) return;

            document.getElementById('projectionMonth').value = month;
            document.getElementById('projectionSeasonalFactor').value = data.seasonalFactor;
            document.getElementById('projectionBaseline').value = data.baseline;
            document.getElementById('projectionActual').value = data.actual;
            
            document.getElementById('addProjectionForm').classList.remove('hidden');
        }

        function deleteProjectionData(month) {
            if (confirm(`Delete projection data for ${month}?`)) {
                delete projectionHistory[month];
                updateProjectionHistoryTable();
                saveUserData();
                alert('Projection data deleted');
            }
        }

        function importProjectionData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        parseProjectionCSV(e.target.result);
                    } catch (error) {
                        alert('Error reading CSV file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function parseProjectionCSV(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());
            if (lines.length < 4) {
                alert('CSV must have at least 4 rows (Income, Total, Seasonal Factor, etc.)');
                return;
            }

            // Parse the CSV structure similar to your uploaded file
            const months = lines[0].split(',').slice(1, -1); // Skip first and last column
            const totals = lines[1].split(',').slice(1, -1);
            const seasonalFactors = lines[2].split(',').slice(1, -1);
            const baselines = lines[3].split(',').slice(1, -1);
            const actuals = lines.length > 6 ? lines[6].split(',').slice(1, -1) : [];

            let importedCount = 0;
            const currentYear = new Date().getFullYear();

            months.forEach((month, index) => {
                if (!month.trim()) return;
                
                const monthNum = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'].indexOf(month.trim()) + 1;
                
                if (monthNum === 0) return; // Skip invalid months
                
                const monthKey = `${currentYear}-${String(monthNum).padStart(2, '0')}`;
                
                const seasonalFactor = parseFloat(seasonalFactors[index]) || 1.0;
                const baseline = parseFloat(baselines[index]?.replace(/[$,\s]/g, '')) || 0;
                const actual = actuals[index] ? parseFloat(actuals[index].replace(/[$,\s]/g, '')) : 0;
                
                if (baseline > 0) {
                    const conservative = baseline * 0.75;
                    const optimistic = baseline * 1.25;
                    
                    // Calculate vs Conservative target
                    let vsConservativeStatus = 'N/A';
                    let accuracyPercentage = 0;
                    
                    if (actual > 0) {
                        const metTarget = actual >= conservative;
                        vsConservativeStatus = metTarget ? 'Met ✅' : 'Missed ❌';
                        accuracyPercentage = metTarget 
                            ? ((actual - conservative) / conservative * 100)
                            : ((conservative - actual) / conservative * 100);
                    }

                    projectionHistory[monthKey] = {
                        seasonalFactor: seasonalFactor,
                        baseline: baseline,
                        conservative: conservative,
                        optimistic: optimistic,
                        actual: actual,
                        accuracyType: 'vs Conservative',
                        accuracyPercentage: accuracyPercentage,
                        vsConservativeStatus: vsConservativeStatus,
                        imported: true,
                        created: new Date().toISOString()
                    };

                    seasonalFactors[monthKey] = seasonalFactor;
                    importedCount++;
                }
            });

            updateProjectionHistoryTable();
            updateSeasonalFactorHistory();
            saveUserData();
            
            alert(`Imported ${importedCount} months of projection data!`);
        }

        function exportProjectionData() {
            if (Object.keys(projectionHistory).length === 0) {
                alert('No projection data to export');
                return;
            }

            const sortedMonths = Object.keys(projectionHistory).sort();
            const months = ['Month', ...sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return new Date(year, month - 1).toLocaleDateString('en-US', { month: 'short' }).toUpperCase();
            })];
            
            const seasonalFactorRow = ['Seasonal Factor', ...sortedMonths.map(m => projectionHistory[m].seasonalFactor)];
            const baselineRow = ['Baseline Projection', ...sortedMonths.map(m => `$${projectionHistory[m].baseline.toFixed(2)}`)];
            const conservativeRow = ['Conservative Target (-25%)', ...sortedMonths.map(m => `$${projectionHistory[m].conservative.toFixed(2)}`)];
            const optimisticRow = ['Optimistic (+25%)', ...sortedMonths.map(m => `$${projectionHistory[m].optimistic.toFixed(2)}`)];
            const actualRow = ['Actual', ...sortedMonths.map(m => projectionHistory[m].actual > 0 ? `$${projectionHistory[m].actual.toFixed(2)}` : '')];
            const targetMetRow = ['Conservative Target Met', ...sortedMonths.map(m => projectionHistory[m].vsConservativeStatus || 'N/A')];

            const csvContent = [
                months.join(','),
                seasonalFactorRow.join(','),
                baselineRow.join(','),
                conservativeRow.join(','),
                optimisticRow.join(','),
                actualRow.join(','),
                targetMetRow.join(',')
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `projection-history-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Initialize the dashboard
        updateDashboard();
        updateCategoriesView();
        updateRulesView();
        updateSubscriptionsView();
        updateIncomeVarianceAnalysis();
    </script>
</body>
</html>
